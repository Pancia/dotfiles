-- seeds/clipboard.lua
-- Secure clipboard history with encrypted storage
local M = {}

local pasteboard = hs.pasteboard
local json = hs.json

-- Ignored clipboard sources (sensitive data)
local ignoredIdentifiers = {
  ["de.petermaurer.TransientPasteboardType"] = true,
  ["com.typeit4me.clipping"] = true,
  ["Pasteboard generator type"] = true,
  ["com.agilebits.onepassword"] = true,
  ["org.nspasteboard.TransientType"] = true,
  ["org.nspasteboard.ConcealedType"] = true,
  ["org.nspasteboard.AutoGeneratedType"] = true,
}

-- Check if clipboard content should be ignored
local function shouldIgnore()
  local validTypes = pasteboard.typesAvailable()
  if not validTypes then return true end
  for _, ptype in ipairs(validTypes) do
    if ignoredIdentifiers[ptype] then
      return true
    end
  end
  return false
end

-- Get key from Keychain using security CLI
local function getKeyFromKeychain(serviceName)
  local cmd = string.format(
    "security find-generic-password -s %q -a encryption_key -w 2>/dev/null",
    serviceName
  )
  local output, status = hs.execute(cmd)
  if status and output and output ~= "" then
    return output:gsub("%s+", "")
  end
  return nil
end

-- Save key to Keychain using security CLI
local function saveKeyToKeychain(serviceName, key)
  -- First try to delete any existing entry
  hs.execute(string.format(
    "security delete-generic-password -s %q -a encryption_key 2>/dev/null",
    serviceName
  ))
  -- Add new entry
  local cmd = string.format(
    "security add-generic-password -s %q -a encryption_key -w %q",
    serviceName, key
  )
  local _, status = hs.execute(cmd)
  return status
end

-- Get or create encryption key from Keychain
local function getOrCreateKey(serviceName)
  local key = getKeyFromKeychain(serviceName)
  if key then
    return key
  end

  -- Generate new 32-byte hex key
  local output, status = hs.execute("openssl rand -hex 32")
  if not status then
    hs.printf("[clipboard] Failed to generate encryption key")
    return nil
  end

  key = output:gsub("%s+", "")
  if not saveKeyToKeychain(serviceName, key) then
    hs.printf("[clipboard] Failed to save key to Keychain")
    return nil
  end

  hs.printf("[clipboard] Created new encryption key in Keychain")
  return key
end

-- Encrypt data to file (async to avoid blocking keyboard input)
local function encryptToFileAsync(data, key, filepath, callback)
  local jsonStr = json.encode(data)
  if not jsonStr then
    hs.printf("[clipboard] Failed to encode JSON")
    if callback then callback(false) end
    return
  end

  local tmpIn = os.tmpname()
  local f = io.open(tmpIn, "w")
  if not f then
    hs.printf("[clipboard] Failed to create temp file")
    if callback then callback(false) end
    return
  end
  f:write(jsonStr)
  f:close()

  -- Ensure parent directory exists (sync but fast)
  local dir = filepath:match("(.*/)")
  if dir then
    hs.execute(string.format("mkdir -p %q", dir))
  end

  -- Run openssl asynchronously
  local task = hs.task.new("/usr/bin/openssl", function(exitCode, stdout, stderr)
    os.remove(tmpIn)
    if exitCode ~= 0 then
      hs.printf("[clipboard] Encryption failed: %s", stderr or "unknown error")
      if callback then callback(false) end
      return
    end
    if callback then callback(true) end
  end, {
    "enc", "-aes-256-cbc", "-salt", "-pbkdf2",
    "-in", tmpIn,
    "-out", filepath,
    "-pass", "pass:" .. key
  })

  if not task:start() then
    os.remove(tmpIn)
    hs.printf("[clipboard] Failed to start encryption task")
    if callback then callback(false) end
  end
end

-- Decrypt data from file
local function decryptFromFile(key, filepath)
  -- Check if file exists
  local f = io.open(filepath, "r")
  if not f then
    return {} -- No history yet
  end
  f:close()

  local tmpOut = os.tmpname()
  local cmd = string.format(
    "openssl enc -aes-256-cbc -d -pbkdf2 -in %q -out %q -pass pass:%s 2>/dev/null",
    filepath, tmpOut, key
  )
  local _, status = hs.execute(cmd)

  if not status then
    os.remove(tmpOut)
    hs.printf("[clipboard] Decryption failed - starting with empty history")
    return {}
  end

  local file = io.open(tmpOut, "r")
  if not file then
    os.remove(tmpOut)
    return {}
  end

  local content = file:read("*a")
  file:close()
  os.remove(tmpOut)

  local data = json.decode(content)
  if not data then
    hs.printf("[clipboard] Failed to decode JSON - starting with empty history")
    return {}
  end

  return data
end

-- Deduplicate and resize history
local function dedupeAndResize(history, maxSize)
  local seen = {}
  local result = {}

  for _, item in ipairs(history) do
    local hash = hs.hash.MD5(item)
    if not seen[hash] then
      seen[hash] = true
      table.insert(result, item)
      if #result >= maxSize then
        break
      end
    end
  end

  return result
end

function M:start(config)
  config = config or {}

  self.frequency = config.frequency or 0.8
  self.hist_size = config.hist_size or 50
  self.paste_on_select = config.paste_on_select or false
  self.show_copied_alert = config.show_copied_alert ~= false -- default true
  self.display_max_length = config.display_max_length or 100
  self.service_name = config.service_name or "SecureClipboard"
  self.storage_path = config.storage_path or
    os.getenv("HOME") .. "/ProtonDrive/hammerspoon/clipboard_history.enc"

  -- Get encryption key
  self.key = getOrCreateKey(self.service_name)
  if not self.key then
    hs.printf("[clipboard] No encryption key - clipboard history disabled")
    return self
  end

  -- Load history
  self.history = decryptFromFile(self.key, self.storage_path)
  self.history = dedupeAndResize(self.history, self.hist_size)
  hs.printf("[clipboard] Loaded %d items", #self.history)

  -- Async save state
  self._saving = false
  self._pendingSave = false

  -- Track clipboard changes
  self.lastChange = pasteboard.changeCount()

  -- Start polling timer
  self.timer = hs.timer.new(self.frequency, function()
    self:checkClipboard()
  end)
  self.timer:start()

  -- Create chooser
  self.chooser = hs.chooser.new(function(choice)
    self:onChoice(choice)
  end)
  self.chooser:queryChangedCallback(function(query)
    self.chooser:choices(self:buildChoices(query))
  end)
  self.chooser:searchSubText(true)

  -- Bind hotkey
  if config.hotkey then
    self.hotkey = hs.hotkey.bind(config.hotkey[1], config.hotkey[2], function()
      self:toggle()
    end)
  end

  return self
end

function M:stop()
  if self.timer then
    self.timer:stop()
    self.timer = nil
  end
  if self.chooser then
    self.chooser:delete()
    self.chooser = nil
  end
  if self.hotkey then
    self.hotkey:delete()
    self.hotkey = nil
  end
end

function M:checkClipboard()
  local currentChange = pasteboard.changeCount()
  if currentChange <= self.lastChange then
    return
  end
  self.lastChange = currentChange

  -- Skip ignored sources
  if shouldIgnore() then
    return
  end

  -- Get text content
  local content = pasteboard.getContents()
  if not content or content == "" then
    return
  end

  -- Skip if same as most recent
  if self.history[1] == content then
    return
  end

  -- Add to history (newest first)
  table.insert(self.history, 1, content)

  -- Dedupe and resize
  self.history = dedupeAndResize(self.history, self.hist_size)

  -- Persist
  self:save()

  -- Show alert
  if self.show_copied_alert then
    local preview = content:gsub("\n", " "):gsub("%s+", " ")
    if #preview > 40 then
      preview = preview:sub(1, 40) .. "..."
    end
    hs.alert.show("Copied: " .. preview, 0.5)
  end
end

function M:save()
  if not self.key then return end

  -- If already saving, mark that we need another save when done
  if self._saving then
    self._pendingSave = true
    return
  end

  self._saving = true
  local historySnapshot = {table.unpack(self.history)} -- Copy to avoid race conditions

  encryptToFileAsync(historySnapshot, self.key, self.storage_path, function(success)
    self._saving = false

    -- If more changes came in while saving, save again
    if self._pendingSave then
      self._pendingSave = false
      self:save()
    end
  end)
end

function M:buildChoices(query)
  local choices = {}
  query = query and query:lower() or ""

  for i, item in ipairs(self.history) do
    local matchText = item:lower()
    if query == "" or matchText:find(query, 1, true) then
      local display = item:gsub("\n", " "):gsub("%s+", " ")
      if #display > self.display_max_length then
        display = display:sub(1, self.display_max_length) .. "..."
      end

      table.insert(choices, {
        text = display,
        subText = string.format("#%d - %d chars", i, #item),
        content = item,
        index = i
      })
    end
  end

  -- Add clear option at end
  if #self.history > 0 then
    table.insert(choices, {
      text = "Clear History",
      subText = string.format("Delete all %d items", #self.history),
      action = "clear"
    })
  end

  return choices
end

function M:onChoice(choice)
  if not choice then return end

  if choice.action == "clear" then
    self.history = {}
    self:save()
    hs.alert.show("Clipboard history cleared")
    return
  end

  if choice.content then
    -- Set clipboard
    pasteboard.setContents(choice.content)
    self.lastChange = pasteboard.changeCount()

    -- Optionally paste
    if self.paste_on_select then
      hs.timer.doAfter(0.1, function()
        hs.eventtap.keyStroke({"cmd"}, "v")
      end)
    end
  end
end

function M:toggle()
  if self.chooser:isVisible() then
    self.chooser:hide()
  else
    self.chooser:choices(self:buildChoices())
    self.chooser:show()
  end
end

function M:show()
  self.chooser:choices(self:buildChoices())
  self.chooser:show()
end

function M:hide()
  self.chooser:hide()
end

return M
