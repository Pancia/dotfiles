#!/usr/bin/env ruby

require "cli.rb"

$cmds_base_dir = "/Users/#{%x[whoami].strip}/dotfiles/cmds/"
$cmds_file = "/Users/#{%x[whoami].strip}/dotfiles/cmds/#{%x[pwd].strip}/cmds.rb"

module EXE
  def self.system(command, opts={silent: false})
    temp = "/tmp/command.zsh"
    pretty_command = command.lstrip.split(/\s\s+/).join(" \\\n")
    unless opts[:silent]
      File.write(temp, pretty_command)
      Kernel.system("bat -P #{temp}")
    end
    Kernel.system("export DISABLE_AUTO_TITLE='true'")
    Kernel.system("printf '\e]1;#{command.strip.split(/\s\s+/).join(" ")}\a'")
    Kernel.system(command)
    exitstatus = $?.exitstatus
    Kernel.system("export DISABLE_AUTO_TITLE=''")
    exit exitstatus if exitstatus
  end
end

module CMD end
class CMDS extend CMD
  def self.list(opts)
    opts.info = "List available commands at the current working directory."
    lambda {
      commands = CMDS.methods - $old_methods
      if not commands.empty?
        puts commands.map(&:to_s).join(" ")
      else
        exit 1
      end
    }
  end
  def self.edit(opts)
    opts.banner = "Usage: cmds edit [function_name]"
    opts.info = "Edit cmds.rb file. If function_name given and doesn't exist, creates it from template."
    lambda { |*args|
      func_name = args.first

      if not File.file? $cmds_file
        system("mkdir -p $(dirname #{$cmds_file})")
        system("cp #{$cmds_base_dir}/template.rb #{$cmds_file}")
      end

      if func_name
        content = File.read($cmds_file)
        # Check if function already exists
        unless content.match?(/def\s+#{Regexp.escape(func_name)}\s*\(/)
          # Extract template function and adapt it
          func_template = <<~RUBY.chomp

	def #{func_name}(opts)
		opts.banner = "Usage: #{func_name} FIXME"
		opts.info = "FIXME"
		lambda { |*args|
			EXE.system %{
				echo "FIXME"
			}
		}
	end
          RUBY
          # Insert before the 'end' that closes module CMD (first unindented 'end')
          new_content = content.sub(/^(module CMD\b.*?)(^end\b)/m) { "#{$1}#{func_template}\n#{$2}" }
          File.write($cmds_file, new_content)
          # Open vim at the function, searching for FIXME to enable easy tabbing
          system("$EDITOR '+/def #{func_name}' '+normal zt' '+/FIXME' #{$cmds_file}")
          return
        end
      end

      system("$EDITOR #{$cmds_file}")
    }
  end
  def self.trash(opts)
    opts.info = "Move cmds.rb file to trash."
    lambda {
      if File.exist? $cmds_file
        system("zsh -ic 'trash #{$cmds_file}'")
      end
    }
  end
end

$old_methods = CMDS.methods
begin require $cmds_file if File.file? $cmds_file; rescue Exception => e; p e end

# NOTE: [[~/dotfiles/wiki/zsh_completion.wiki]]
CLI.parse!(CMDS) { |opts|
  opts.on("-z", "--zsh-completions", "print zsh completion") do
    cmds = (CMDS.methods - Object.methods).map(&:to_s).join " "
    puts ["_arguments", "-s", "-S",
          "-h[Print this help document]",
          "--help[Print this help document]",
          "-v[Print more, for debugging]",
          "--verbose[Print more, for debugging]",
          "-n[Dry Run / Simulation, prints commands instead of executing.]",
          "--dry-run[Dry Run / Simulation, prints commands instead of executing.]",
          "1:cmd:(#{cmds})", "*:::arg:{_normal}"
    ].join "&"
    $options[:helped] = true
  end
}
