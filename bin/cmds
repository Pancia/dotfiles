#!/usr/bin/env ruby

require "cli.rb"
require "shellwords"

$user = %x[whoami].strip
$pwd = %x[pwd].strip

$cmds_roots = [
  "/Users/#{$user}/dotfiles/cmds",
  "/Users/#{$user}/private/cmds",
]

# Resolve cmds.rb: first existing match, or default to first root
$cmds_file = $cmds_roots.map { |r| "#{r}/#{$pwd}/cmds.rb" }.find { |f| File.file?(f) } ||
             "#{$cmds_roots.first}/#{$pwd}/cmds.rb"
$cmds_base_dir = $cmds_roots.first

module EXE
  def self.bash(command, opts={silent: false})
    cmd_name = command.strip.split(/\s/).first.split('/').last.gsub(/[^a-zA-Z0-9_-]/, '_')[0..20]
    dir_name = File.basename(Dir.pwd)
    timestamp = Time.now.strftime("%Y-%m-%d %H:%M:%S")
    temp = "/tmp/#{cmd_name} @ #{dir_name} @ #{timestamp}.bash"
    pretty_command = command.lstrip.split(/\s\s+/).join(" \\\n")
    unless opts[:silent]
      File.write(temp, pretty_command)
      Kernel.system("bat -P --style=header,grid #{temp.shellescape}")
    end
    Kernel.system("export DISABLE_AUTO_TITLE='true'")
    Kernel.system("printf '\e]1;#{command.strip.split(/\s\s+/).join(" ")}\a'")
    saved_stty = `stty -g 2>/dev/null`.strip rescue nil
    begin
      Kernel.system(command)
      exitstatus = $?.exitstatus
    ensure
      system("stty #{saved_stty} 2>/dev/null") if saved_stty && !saved_stty.empty?
    end
    Kernel.system("export DISABLE_AUTO_TITLE=''")
    exit exitstatus if exitstatus
  end

  def self.fish(command, opts={silent: false})
    cmd_name = command.strip.split(/\s/).first.split('/').last.gsub(/[^a-zA-Z0-9_-]/, '_')[0..20]
    dir_name = File.basename(Dir.pwd)
    timestamp = Time.now.strftime("%Y-%m-%d %H:%M:%S")
    temp = "/tmp/#{cmd_name} @ #{dir_name} @ #{timestamp}.fish"
    pretty_command = command.lstrip.split(/\s\s+/).join(" \\\n")
    unless opts[:silent]
      File.write(temp, pretty_command)
      Kernel.system("bat -P --style=header,grid #{temp.shellescape}")
    end
    Kernel.system("fish", "-c", command)
    exitstatus = $?.exitstatus
    exit exitstatus if exitstatus
  end
end

module CMD end
class CMDS extend CMD
  def self.list(opts)
    opts.info = "List available commands at the current working directory."
    lambda {
      commands = CMDS.methods - $old_methods
      if not commands.empty?
        puts commands.map(&:to_s).join(" ")
      else
        exit 1
      end
    }
  end
  def self.edit(opts)
    opts.banner = "Usage: cmds edit [function_name]"
    opts.info = "Edit cmds.rb file. If function_name given and doesn't exist, creates it from template."
    lambda { |*args|
      func_name = args.first

      if not File.file? $cmds_file
        system("mkdir -p $(dirname #{$cmds_file})")
        system("cp #{$cmds_base_dir}/template.rb #{$cmds_file}")
      end

      if func_name
        content = File.read($cmds_file)
        # Scaffold function if it doesn't exist
        unless content.match?(/def\s+#{Regexp.escape(func_name)}\s*\(/)
          func_template = "\n" \
            "  def #{func_name}(opts)\n" \
            "    opts.banner = \"Usage: #{func_name} FIXME\"\n" \
            "    opts.info = \"FIXME\"\n" \
            "    lambda { |*args|\n" \
            "      EXE.bash %{\n" \
            "        echo \"FIXME\"\n" \
            "      }\n" \
            "    }\n" \
            "  end"
          new_content = content.sub(/^(module CMD\b.*?)(^end\b)/m) { "#{$1}#{func_template}\n#{$2}" }
          File.write($cmds_file, new_content)
        end
        system("$EDITOR '+/def #{func_name}' '+normal zt' #{$cmds_file}")
      else
        system("$EDITOR #{$cmds_file}")
      end
    }
  end
  def self.trash(opts)
    opts.info = "Move cmds.rb file to trash."
    lambda {
      if File.exist? $cmds_file
        system("fish -c 'trash #{$cmds_file}'")
      end
    }
  end
  def self.show(opts)
    opts.banner = "Usage: cmds show [function_name]"
    opts.info = "Show all commands or a specific function's source code."
    lambda { |*args|
      func_name = args.first

      unless File.file? $cmds_file
        STDERR.puts "No cmds.rb file at #{$cmds_file}"
        exit 1
      end

      content = File.read($cmds_file)

      if func_name
        # Extract specific function
        if match = content.match(/^(\s*def\s+#{Regexp.escape(func_name)}\s*\(.*?^\s*end)/m)
          IO.popen("bat -l ruby -P", "w") { |io| io.puts match[1] }
        else
          STDERR.puts "Function '#{func_name}' not found"
          exit 1
        end
      else
        # Show all functions with bat syntax highlighting
        system("bat -l ruby -P #{$cmds_file}")
      end
    }
  end
  def self.path(opts)
    opts.info = "Print the cmds.rb file path for the current directory."
    lambda {
      puts $cmds_file
    }
  end
  def self.describe(opts)
    opts.info = "List commands with descriptions (plain text, no formatting)."
    lambda {
      commands = CMDS.methods - $old_methods
      commands.sort.each do |cmd|
        o = OptionParser.new
        CMDS.send(cmd, o)
        puts "#{cmd}: #{o.info}"
      end
    }
  end
  def self.init(opts)
    opts.banner = "Usage: cmds init [function_name]"
    opts.info = "Create cmds.rb from template (no editor). Optionally scaffold a function."
    lambda { |*args|
      if File.file? $cmds_file
        STDERR.puts "Already exists: #{$cmds_file}"
        puts $cmds_file
        return
      end
      system("mkdir -p #{File.dirname($cmds_file).shellescape}")
      system("cp #{$cmds_base_dir}/template.rb #{$cmds_file}")
      func_name = args.first
      if func_name
        content = File.read($cmds_file)
        func_template = "\n" \
          "  def #{func_name}(opts)\n" \
          "    opts.banner = \"Usage: #{func_name} FIXME\"\n" \
          "    opts.info = \"FIXME\"\n" \
          "    lambda { |*args|\n" \
          "      EXE.bash %{\n" \
          "        echo \"FIXME\"\n" \
          "      }\n" \
          "    }\n" \
          "  end"
        new_content = content.sub(/^(module CMD\b.*?)(^end\b)/m) { "#{$1}#{func_template}\n#{$2}" }
        File.write($cmds_file, new_content)
      end
      puts $cmds_file
    }
  end
end

$old_methods = CMDS.methods
begin require $cmds_file if File.file? $cmds_file; rescue Exception => e; p e end

dir_name = File.basename(Dir.pwd)
cmd_name = ARGV.first || "cmds"
if !ENV['CMDS_LABELED']
  ENV['CMDS_LABELED'] = '1'
  exec("proc-label", "cmds:#{cmd_name} [#{dir_name}]", "ruby", $0, *ARGV)
end

# NOTE: [[~/dotfiles/wiki/zsh_completion.wiki]]
CLI.parse!(CMDS) { |opts|
  opts.on("-z", "--zsh-completions", "print zsh completion") do
    cmds = (CMDS.methods - Object.methods).map(&:to_s).join " "
    puts ["_arguments", "-s", "-S",
          "-h[Print this help document]",
          "--help[Print this help document]",
          "-v[Print more, for debugging]",
          "--verbose[Print more, for debugging]",
          "-n[Dry Run / Simulation, prints commands instead of executing.]",
          "--dry-run[Dry Run / Simulation, prints commands instead of executing.]",
          "1:cmd:(#{cmds})", "*:::arg:{_normal}"
    ].join "&"
    $options[:helped] = true
  end
}
