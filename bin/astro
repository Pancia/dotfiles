#!/usr/bin/env -S uv run --with kerykeion --with pyswisseph python3
"""
Astrological Transit Tracker

CLI tool for tracking astrological transits against natal charts.
Uses kerykeion for calculations, stores data in ~/Cloud/astro/.

Usage:
    astro add-chart [NAME]       # Create natal chart interactively
    astro list-charts            # Show saved charts
    astro show-chart [NAME]      # Display chart details
    astro remove-chart NAME      # Delete a chart
    astro now [NAME]             # Current transits
    astro forecast [NAME] --days N   # N-day forecast from today
    astro forecast --date YYYY-MM-DD # Forecast from specific date
    astro mundane --days N       # Mundane transits (transit-to-transit)

Run with: uv run --with kerykeion ~/dotfiles/bin/astro <command>
"""

import argparse
import json
import sys
import swisseph as swe
from dataclasses import dataclass, asdict, field
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional


# =============================================================================
# Data Models
# =============================================================================

@dataclass
class BirthData:
    """Birth data for a natal chart."""
    full_name: str
    year: int
    month: int
    day: int
    hour: int
    minute: int
    city: str
    nation: str
    lat: float = 0.0
    lng: float = 0.0
    tz_str: str = ""


@dataclass
class NatalChart:
    """A saved natal chart."""
    name: str
    birth_data: BirthData
    created_at: str
    notes: str = ""


@dataclass
class TransitEvent:
    """A single transit aspect."""
    transit_planet: str
    natal_planet: str
    aspect: str
    orb: float
    transit_sign: str = ""
    transit_house: str = ""
    natal_sign: str = ""
    natal_house: str = ""
    applying: bool = True
    exact_date: Optional[str] = None


@dataclass
class PlanetTrackingEvent:
    """Event for planet tracking over time."""
    date: str  # ISO format YYYY-MM-DD
    planet: str  # Planet name
    event_type: str  # 'sign_change', 'house_change', 'station_retrograde', 'station_direct', 'aspect'

    # Position (always present)
    sign: str
    house: str

    # Sign change fields
    from_sign: str = ""
    to_sign: str = ""

    # House change fields
    from_house: str = ""
    to_house: str = ""

    # Station fields
    degree: float = 0.0  # Exact degree of station
    speed: float = 0.0  # Daily motion in degrees/day

    # Aspect fields (reuse TransitEvent structure)
    natal_planet: str = ""
    aspect: str = ""  # conjunction, opposition, trine, square, sextile
    orb: float = 0.0
    natal_sign: str = ""
    natal_house: str = ""


@dataclass
class AsteroidObject:
    """Wrapper for Swiss Ephemeris asteroid calculations."""
    name: str
    abs_pos: float      # Ecliptic longitude (0-360Â°)
    sign: str           # Zodiac sign (Ari, Tau, etc.)
    speed: float        # Daily motion (degrees/day)
    house: str = ""     # Transit house (usually unused, calculated from natal cusps)

    _ephe_path_set = False  # Class variable to track if path is configured

    @staticmethod
    def from_swisseph(name: str, jd: float, body_num: int) -> 'AsteroidObject':
        """Calculate asteroid position using Swiss Ephemeris."""
        # Set ephemeris path on first use (kerykeion bundles the data files)
        if not AsteroidObject._ephe_path_set:
            try:
                import kerykeion
                from pathlib import Path
                kerykeion_path = Path(kerykeion.__file__).parent
                ephe_path = kerykeion_path / "sweph"
                if ephe_path.exists():
                    swe.set_ephe_path(str(ephe_path))
                AsteroidObject._ephe_path_set = True
            except Exception:
                pass  # Fall back to default path

        result, flags = swe.calc_ut(jd, body_num)

        longitude = result[0]  # Ecliptic longitude
        speed = result[3]      # Daily motion

        # Convert longitude to sign
        signs = ['Ari', 'Tau', 'Gem', 'Can', 'Leo', 'Vir',
                 'Lib', 'Sco', 'Sag', 'Cap', 'Aqu', 'Pis']
        sign_idx = int(longitude / 30)
        sign = signs[sign_idx]

        return AsteroidObject(
            name=name,
            abs_pos=longitude,
            sign=sign,
            speed=speed
        )


@dataclass
class Config:
    """User configuration."""
    default_chart: str = "default"
    geonames_username: str = "pancia"
    orb_settings: dict = field(default_factory=lambda: {
        "conjunction": 8,
        "opposition": 8,
        "trine": 6,
        "square": 6,
        "sextile": 4
    })
    display_format: str = "compact"


# =============================================================================
# Storage Layer
# =============================================================================

class AstroStorage:
    """Handles all file I/O operations."""

    def __init__(self, base_path: Optional[Path] = None):
        self.base_path = base_path or Path.home() / ".local" / "share" / "astro"
        self.charts_dir = self.base_path / "charts"
        self.transits_dir = self.base_path / "transits"
        self.ephemeris_dir = self.base_path / "ephemeris_cache"
        self.config_file = self.base_path / "config.json"
        self._ensure_dirs()

    def _ensure_dirs(self):
        """Create directory structure if missing."""
        self.charts_dir.mkdir(parents=True, exist_ok=True)
        self.transits_dir.mkdir(parents=True, exist_ok=True)
        self.ephemeris_dir.mkdir(parents=True, exist_ok=True)

    # --- Config ---

    def load_config(self) -> Config:
        """Load user configuration."""
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                data = json.load(f)
                return Config(**data)
        return Config()

    def save_config(self, config: Config) -> None:
        """Save user configuration."""
        with open(self.config_file, 'w') as f:
            json.dump(asdict(config), f, indent=2)

    # --- Charts ---

    def save_chart(self, chart: NatalChart) -> None:
        """Save natal chart to JSON."""
        filepath = self.charts_dir / f"{chart.name}.json"
        with open(filepath, 'w') as f:
            json.dump(asdict(chart), f, indent=2)

    def load_chart(self, name: str) -> NatalChart:
        """Load natal chart from JSON."""
        filepath = self.charts_dir / f"{name}.json"
        if not filepath.exists():
            raise FileNotFoundError(f"Chart '{name}' not found. "
                                    f"Run 'astro add-chart {name}' to create it.")
        with open(filepath, 'r') as f:
            data = json.load(f)
        return NatalChart(
            name=data['name'],
            birth_data=BirthData(**data['birth_data']),
            created_at=data['created_at'],
            notes=data.get('notes', '')
        )

    def list_charts(self) -> list[str]:
        """Return list of chart names."""
        return sorted([f.stem for f in self.charts_dir.glob("*.json")])

    def delete_chart(self, name: str) -> bool:
        """Delete a chart. Returns True if deleted."""
        filepath = self.charts_dir / f"{name}.json"
        if filepath.exists():
            filepath.unlink()
            return True
        return False

    # --- Transit Cache ---

    def get_cached_transit(self, date: str, chart_name: str) -> Optional[dict]:
        """Retrieve cached transit data for a date."""
        year_month = date[:7]  # YYYY-MM
        filepath = self.transits_dir / year_month / f"{date}_{chart_name}.json"
        if filepath.exists():
            with open(filepath, 'r') as f:
                return json.load(f)
        return None

    def cache_transit(self, date: str, chart_name: str, aspects: list[TransitEvent]) -> None:
        """Cache transit data for a date."""
        year_month = date[:7]
        month_dir = self.transits_dir / year_month
        month_dir.mkdir(parents=True, exist_ok=True)

        filepath = month_dir / f"{date}_{chart_name}.json"
        data = {
            'date': date,
            'chart_name': chart_name,
            'computed_at': datetime.now().isoformat(),
            'aspects': [asdict(a) for a in aspects]
        }
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)

    def clear_cache(self) -> int:
        """Clear all cached transits. Returns count of deleted files."""
        count = 0
        for month_dir in self.transits_dir.iterdir():
            if month_dir.is_dir():
                for cache_file in month_dir.glob("*.json"):
                    cache_file.unlink()
                    count += 1
                month_dir.rmdir()
        return count


# =============================================================================
# Chart Manager
# =============================================================================

class ChartManager:
    """Manages natal chart operations."""

    def __init__(self, storage: AstroStorage):
        self.storage = storage

    def create_chart_interactive(self, name: Optional[str] = None) -> NatalChart:
        """Interactive chart creation using input()."""
        print("Create New Natal Chart")
        print("=" * 40)
        print()

        if not name:
            name = input("Chart name (e.g., 'default', 'partner'): ").strip()
            if not name:
                name = "default"

        # Check if already exists
        existing = self.storage.list_charts()
        if name in existing:
            overwrite = input(f"Chart '{name}' exists. Overwrite? (y/N): ").strip().lower()
            if overwrite != 'y':
                print("Aborted.")
                sys.exit(0)

        print()
        full_name = input("Full name: ").strip()

        print()
        print("Birth date:")
        year = self._input_int("  Year (YYYY): ", 1900, 2100)
        month = self._input_int("  Month (1-12): ", 1, 12)
        day = self._input_int("  Day (1-31): ", 1, 31)

        print()
        print("Birth time (24-hour format):")
        hour = self._input_int("  Hour (0-23): ", 0, 23)
        minute = self._input_int("  Minute (0-59): ", 0, 59)

        print()
        print("Birth location:")
        city = input("  City: ").strip()
        nation = input("  Nation code (e.g., US, UK, DE): ").strip().upper()

        # Create birth data (kerykeion will geocode city)
        birth_data = BirthData(
            full_name=full_name,
            year=year,
            month=month,
            day=day,
            hour=hour,
            minute=minute,
            city=city,
            nation=nation
        )

        chart = NatalChart(
            name=name,
            birth_data=birth_data,
            created_at=datetime.now().isoformat()
        )

        self.storage.save_chart(chart)
        return chart

    def _input_int(self, prompt: str, min_val: int, max_val: int) -> int:
        """Get integer input with validation."""
        while True:
            try:
                val = int(input(prompt))
                if min_val <= val <= max_val:
                    return val
                print(f"  Please enter a value between {min_val} and {max_val}")
            except ValueError:
                print("  Please enter a valid number")


# =============================================================================
# Transit Calculator
# =============================================================================

class TransitCalculator:
    """Computes transits using kerykeion."""

    def __init__(self, storage: AstroStorage):
        self.storage = storage
        self.config = storage.load_config()

    def _make_subject(self, name: str, year: int, month: int, day: int,
                      hour: int, minute: int, bd: BirthData) -> 'AstrologicalSubject':
        """Create AstrologicalSubject, using cached coords if available."""
        from kerykeion import AstrologicalSubject

        # Use cached coordinates if available
        if bd.lat and bd.lng and bd.tz_str:
            return AstrologicalSubject(
                name, year, month, day, hour, minute,
                bd.city, bd.nation,
                lat=bd.lat, lng=bd.lng, tz_str=bd.tz_str,
                houses_system_identifier="W"
            )
        else:
            return AstrologicalSubject(
                name, year, month, day, hour, minute,
                bd.city, bd.nation,
                houses_system_identifier="W",
                geonames_username=self.config.geonames_username
            )

    def _cache_coords(self, natal_chart: NatalChart, subject) -> None:
        """Save geocoded coordinates back to chart."""
        bd = natal_chart.birth_data
        if not bd.lat or not bd.lng:
            bd.lat = subject.lat
            bd.lng = subject.lng
            bd.tz_str = subject.tz_str
            self.storage.save_chart(natal_chart)

    def _calculate_natal_houses(self, natal_subject) -> dict[int, float]:
        """
        Extract natal house cusp positions.
        Returns dict mapping house number (1-12) to cusp degree (0-360).
        """
        house_attrs = [
            ('first_house', 1), ('second_house', 2), ('third_house', 3),
            ('fourth_house', 4), ('fifth_house', 5), ('sixth_house', 6),
            ('seventh_house', 7), ('eighth_house', 8), ('ninth_house', 9),
            ('tenth_house', 10), ('eleventh_house', 11), ('twelfth_house', 12),
        ]

        natal_cusps = {}
        for attr_name, house_num in house_attrs:
            if hasattr(natal_subject, attr_name):
                house_obj = getattr(natal_subject, attr_name)
                # Each house is a KerykeionPointModel with abs_pos attribute
                natal_cusps[house_num] = house_obj.abs_pos

        # Validate we got all 12 houses
        if len(natal_cusps) != 12:
            raise ValueError(f"Could not extract all 12 house cusps. Got {len(natal_cusps)} houses.")

        return natal_cusps

    def _planet_in_natal_house(self, planet_abs_pos: float, natal_cusps: dict[int, float]) -> str:
        """
        Determine which natal house a planet is in based on its ecliptic position.

        Args:
            planet_abs_pos: Planet's absolute position (0-360 degrees)
            natal_cusps: Dict of house number -> cusp degree

        Returns:
            House number as string (e.g., '1', '2', ... '12')
        """
        # Normalize position to 0-360
        pos = planet_abs_pos % 360

        # Sort houses by cusp position
        sorted_houses = sorted(natal_cusps.items(), key=lambda x: x[1])

        # Find which house the planet falls into
        # A planet is in house N if it's between cusp N and cusp N+1
        for i, (house_num, cusp_deg) in enumerate(sorted_houses):
            next_house_num, next_cusp_deg = sorted_houses[(i + 1) % 12]

            # Handle zodiac wraparound (12th house wraps to 1st house)
            if next_cusp_deg < cusp_deg:  # Wraparound case
                if pos >= cusp_deg or pos < next_cusp_deg:
                    return str(house_num)
            else:  # Normal case
                if cusp_deg <= pos < next_cusp_deg:
                    return str(house_num)

        # Fallback (shouldn't reach here)
        return '1'

    def compute_current_transits(self, natal_chart: NatalChart) -> list[TransitEvent]:
        """Compute transits for the current moment."""
        from kerykeion import SynastryAspects

        bd = natal_chart.birth_data

        # Create natal subject
        natal = self._make_subject(
            bd.full_name, bd.year, bd.month, bd.day, bd.hour, bd.minute, bd
        )
        self._cache_coords(natal_chart, natal)

        # Create transit subject for now
        now = datetime.now()
        transit = self._make_subject(
            "Transit", now.year, now.month, now.day, now.hour, now.minute, bd
        )

        # Calculate aspects
        aspects = SynastryAspects(transit, natal)
        return self._parse_aspects(aspects.relevant_aspects, transit, natal)

    def compute_day_transits(self, natal_chart: NatalChart, date) -> list[TransitEvent]:
        """Compute transits for a specific date (at noon)."""
        from kerykeion import SynastryAspects

        bd = natal_chart.birth_data

        # Create natal subject
        natal = self._make_subject(
            bd.full_name, bd.year, bd.month, bd.day, bd.hour, bd.minute, bd
        )
        self._cache_coords(natal_chart, natal)

        # Create transit subject for the date at noon
        transit = self._make_subject(
            "Transit", date.year, date.month, date.day, 12, 0, bd
        )

        # Calculate aspects
        aspects = SynastryAspects(transit, natal)
        return self._parse_aspects(aspects.relevant_aspects, transit, natal)

    # Major planets only (skip points, nodes, lilith, etc.)
    MAJOR_PLANETS = {'Sun', 'Moon', 'Mercury', 'Venus', 'Mars',
                     'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto'}

    # Swiss Ephemeris asteroid body numbers
    ASTEROIDS = {
        'ceres': 17,   # swe.CERES
        'pallas': 18,  # swe.PALLAS
        'juno': 19,    # swe.JUNO
        'vesta': 20,   # swe.VESTA
    }

    def get_lunar_phase(self, date, bd: BirthData) -> Optional[TransitEvent]:
        """Check if date has a new or full moon (orb < 2Â°)."""
        transit = self._make_subject("Transit", date.year, date.month, date.day, 12, 0, bd)

        sun_pos = transit.sun.abs_pos
        moon_pos = transit.moon.abs_pos

        # Calculate aspect
        diff = abs(sun_pos - moon_pos)
        if diff > 180:
            diff = 360 - diff

        # New Moon = conjunction (diff near 0)
        if diff < 2.0:
            return TransitEvent(
                transit_planet="New Moon",
                natal_planet="",
                aspect="conjunction",
                orb=diff,
                transit_sign=transit.moon.sign,
                transit_house="",
            )
        # Full Moon = opposition (diff near 180)
        elif abs(diff - 180) < 2.0:
            return TransitEvent(
                transit_planet="Full Moon",
                natal_planet="",
                aspect="opposition",
                orb=abs(diff - 180),
                transit_sign=transit.moon.sign,
                transit_house="",
            )
        return None

    def forecast_transits(self, natal_chart: NatalChart, days: int,
                          orb_limit: float = 0.5, major_only: bool = True,
                          start_date: Optional[datetime] = None
                          ) -> list[tuple[str, list[TransitEvent]]]:
        """
        Forecast transits for N days starting from a date.
        Returns list of (date_str, events) tuples.

        Args:
            days: Number of days to forecast
            orb_limit: Max orb to include (default 0.5Â° for "exact" transits)
            major_only: Only show major planet transits (default True)
            start_date: Starting date (default: today)
        """
        results = []
        today = start_date.date() if start_date else datetime.now().date()

        for day_offset in range(days):
            date = today + timedelta(days=day_offset)
            date_str = date.isoformat()

            # Check cache first
            cached = self.storage.get_cached_transit(date_str, natal_chart.name)
            if cached:
                events = [TransitEvent(**e) for e in cached['aspects']]
            else:
                # Compute for this day
                events = self.compute_day_transits(natal_chart, date)
                self.storage.cache_transit(date_str, natal_chart.name, events)

            # Filter to highlights
            highlights = []
            for e in events:
                if abs(e.orb) > orb_limit:
                    continue
                if major_only:
                    if e.transit_planet not in self.MAJOR_PLANETS:
                        continue
                    if e.natal_planet not in self.MAJOR_PLANETS:
                        continue
                highlights.append(e)

            # Check for lunar phases
            lunar = self.get_lunar_phase(date, natal_chart.birth_data)
            if lunar:
                highlights.insert(0, lunar)

            if highlights:
                results.append((date_str, highlights))

        return results

    def track_planet(self, natal_chart: NatalChart, planet_name: str,
                     start_date: datetime, end_date: datetime,
                     include_aspects: bool = True,
                     aspect_orb: float = 1.0) -> list[PlanetTrackingEvent]:
        """
        Track a single planet across a date range.

        Detects: sign changes, house changes, retrograde stations, aspects to natal planets.
        Samples daily at noon. For Moon, could add 6-hour sampling in future.

        Returns chronologically sorted list of events.
        """
        events = []
        bd = natal_chart.birth_data

        # Create natal subject once (for aspect calculations)
        natal = self._make_subject(
            bd.full_name, bd.year, bd.month, bd.day, bd.hour, bd.minute, bd
        )
        self._cache_coords(natal_chart, natal)

        # Calculate natal house cusps once
        natal_cusps = self._calculate_natal_houses(natal)

        # Iterate day by day
        current = start_date.date() if hasattr(start_date, 'date') else start_date
        end = end_date.date() if hasattr(end_date, 'date') else end_date
        prev_subject = None

        while current <= end:
            # Create transit subject at noon
            curr_subject = self._make_subject(
                "Transit", current.year, current.month, current.day, 12, 0, bd
            )

            if prev_subject:
                # Check for state transitions
                if event := self._detect_sign_change(planet_name, current, prev_subject, curr_subject, natal_cusps):
                    events.append(event)

                if event := self._detect_house_change(planet_name, current, prev_subject, curr_subject, natal_cusps):
                    events.append(event)

                if event := self._detect_station(planet_name, current, prev_subject, curr_subject):
                    events.append(event)

            # Check for tight aspects to natal planets
            if include_aspects:
                aspect_events = self._get_planet_aspects(
                    planet_name, current, curr_subject, natal, aspect_orb, natal_cusps
                )
                events.extend(aspect_events)

            prev_subject = curr_subject
            current = current + timedelta(days=1)

        # Post-process aspects to show only entering/exact/leaving
        if include_aspects:
            events = self._filter_aspect_transitions(events)

        return sorted(events, key=lambda e: e.date)

    def _filter_aspect_transitions(self, events: list[PlanetTrackingEvent]) -> list[PlanetTrackingEvent]:
        """
        Filter aspect events to show only entering, exact, and leaving occurrences.
        Handles multiple passes (e.g., during retrograde).
        """
        from itertools import groupby

        # Separate aspect events from other events
        aspect_events = [e for e in events if e.event_type == 'aspect']
        other_events = [e for e in events if e.event_type != 'aspect']

        if not aspect_events:
            return events

        # Sort by date
        aspect_events.sort(key=lambda e: e.date)

        # Group by unique aspect (natal_planet + aspect type)
        def aspect_key(e):
            return (e.natal_planet, e.aspect)

        filtered_aspects = []

        for key, group in groupby(sorted(aspect_events, key=aspect_key), key=aspect_key):
            group_list = list(group)
            group_list.sort(key=lambda e: e.date)

            # Find continuous sequences (gaps > 2 days mean separate passes)
            sequences = []
            current_seq = [group_list[0]]

            for i in range(1, len(group_list)):
                curr_date = datetime.fromisoformat(group_list[i].date)
                prev_date = datetime.fromisoformat(group_list[i-1].date)

                if (curr_date - prev_date).days <= 2:
                    current_seq.append(group_list[i])
                else:
                    # New sequence (e.g., retrograde pass)
                    sequences.append(current_seq)
                    current_seq = [group_list[i]]

            sequences.append(current_seq)

            # For each sequence, keep entering, exact, and leaving
            for seq in sequences:
                if len(seq) == 1:
                    # Single day - mark as exact (use dataclass replace to create copy)
                    from dataclasses import replace
                    event = replace(seq[0], aspect=f"{seq[0].aspect} (exact)")
                    filtered_aspects.append(event)
                else:
                    from dataclasses import replace

                    # Find exact (minimum orb)
                    exact_event = min(seq, key=lambda e: abs(e.orb))

                    # Check if entering/exact/leaving are distinct events
                    entering_idx = 0
                    exact_idx = seq.index(exact_event)
                    leaving_idx = len(seq) - 1

                    # Only add distinct events
                    if entering_idx == exact_idx == leaving_idx:
                        # All same - just add as exact
                        filtered_aspects.append(replace(seq[0], aspect=f"{seq[0].aspect} (exact)"))
                    elif entering_idx == exact_idx:
                        # Entering and exact are same
                        filtered_aspects.append(replace(seq[entering_idx], aspect=f"{seq[entering_idx].aspect} (entering/exact)"))
                        filtered_aspects.append(replace(seq[leaving_idx], aspect=f"{seq[leaving_idx].aspect} (leaving)"))
                    elif exact_idx == leaving_idx:
                        # Exact and leaving are same
                        filtered_aspects.append(replace(seq[entering_idx], aspect=f"{seq[entering_idx].aspect} (entering)"))
                        filtered_aspects.append(replace(seq[exact_idx], aspect=f"{seq[exact_idx].aspect} (exact/leaving)"))
                    else:
                        # All distinct
                        filtered_aspects.append(replace(seq[entering_idx], aspect=f"{seq[entering_idx].aspect} (entering)"))
                        filtered_aspects.append(replace(seq[exact_idx], aspect=f"{seq[exact_idx].aspect} (exact)"))
                        filtered_aspects.append(replace(seq[leaving_idx], aspect=f"{seq[leaving_idx].aspect} (leaving)"))

        return other_events + filtered_aspects

    def _detect_sign_change(self, planet_name: str, date, prev_subj, curr_subj,
                            natal_cusps: dict[int, float]) -> Optional[PlanetTrackingEvent]:
        """Detect when planet changes signs."""
        prev_planet = self._get_planet_obj(prev_subj, planet_name)
        curr_planet = self._get_planet_obj(curr_subj, planet_name)

        if not prev_planet or not curr_planet:
            return None

        if prev_planet.sign != curr_planet.sign:
            house = self._planet_in_natal_house(curr_planet.abs_pos, natal_cusps)
            return PlanetTrackingEvent(
                date=date.isoformat(),
                planet=planet_name,
                event_type='sign_change',
                sign=curr_planet.sign,
                house=house,
                from_sign=prev_planet.sign,
                to_sign=curr_planet.sign,
                degree=curr_planet.abs_pos
            )
        return None

    def _detect_house_change(self, planet_name: str, date, prev_subj, curr_subj,
                             natal_cusps: dict[int, float]) -> Optional[PlanetTrackingEvent]:
        """Detect when planet changes natal houses."""
        prev_planet = self._get_planet_obj(prev_subj, planet_name)
        curr_planet = self._get_planet_obj(curr_subj, planet_name)

        if not prev_planet or not curr_planet:
            return None

        # Calculate house based on natal cusps, not transit subject's houses
        prev_house = self._planet_in_natal_house(prev_planet.abs_pos, natal_cusps)
        curr_house = self._planet_in_natal_house(curr_planet.abs_pos, natal_cusps)

        if prev_house != curr_house:
            return PlanetTrackingEvent(
                date=date.isoformat(),
                planet=planet_name,
                event_type='house_change',
                sign=curr_planet.sign,
                house=curr_house,
                from_house=prev_house,
                to_house=curr_house,
                degree=curr_planet.abs_pos
            )
        return None

    def _detect_station(self, planet_name: str, date, prev_subj, curr_subj) -> Optional[PlanetTrackingEvent]:
        """Detect retrograde/direct stations (when speed crosses zero)."""
        prev_planet = self._get_planet_obj(prev_subj, planet_name)
        curr_planet = self._get_planet_obj(curr_subj, planet_name)

        if not prev_planet or not curr_planet:
            return None

        prev_speed = getattr(prev_planet, 'speed', 0)
        curr_speed = getattr(curr_planet, 'speed', 0)

        # Check if speed changed sign (crossed zero)
        if prev_speed * curr_speed < 0:
            station_type = 'station_direct' if curr_speed > 0 else 'station_retrograde'
            house = self._clean_house(curr_planet.house)

            return PlanetTrackingEvent(
                date=date.isoformat(),
                planet=planet_name,
                event_type=station_type,
                sign=curr_planet.sign,
                house=house,
                degree=curr_planet.abs_pos,
                speed=curr_speed
            )
        return None

    def _get_planet_aspects(self, planet_name: str, date, transit_subj, natal_subj,
                           orb_limit: float, natal_cusps: dict[int, float]) -> list[PlanetTrackingEvent]:
        """Get tight aspects for a specific planet on a date."""
        # Skip aspects for asteroids (kerykeion's SynastryAspects doesn't include them)
        if planet_name.lower() in self.ASTEROIDS:
            return []

        from kerykeion import SynastryAspects

        aspects = SynastryAspects(transit_subj, natal_subj)
        events = []

        for asp in aspects.relevant_aspects:
            # Filter to only this planet's aspects (case-insensitive)
            if asp['p1_name'].lower() != planet_name.lower():
                continue

            # Filter to tight orbs only
            if abs(asp['orbit']) > orb_limit:
                continue

            # Filter to major planets on natal side
            if asp['p2_name'] not in self.MAJOR_PLANETS:
                continue

            # Get position data - calculate transit house using natal cusps
            t_planet = self._get_planet_obj(transit_subj, asp['p1_name'])
            t_sign = t_planet.sign if t_planet else ''
            t_house = self._planet_in_natal_house(t_planet.abs_pos, natal_cusps) if t_planet else ''
            t_degree = t_planet.abs_pos if t_planet else 0.0

            n_sign, n_house = self._get_planet_position(natal_subj, asp['p2_name'])

            events.append(PlanetTrackingEvent(
                date=date.isoformat(),
                planet=planet_name,
                event_type='aspect',
                sign=t_sign,
                house=t_house,
                natal_planet=asp['p2_name'],
                aspect=asp['aspect'],
                orb=asp['orbit'],
                natal_sign=n_sign,
                natal_house=n_house,
                degree=t_degree
            ))

        return events

    def _get_planet_obj(self, subject, planet_name: str):
        """Get planet object from subject by name."""
        # Try kerykeion first (existing planets)
        attr_map = {
            'sun': 'sun', 'moon': 'moon', 'mercury': 'mercury',
            'venus': 'venus', 'mars': 'mars', 'jupiter': 'jupiter',
            'saturn': 'saturn', 'uranus': 'uranus', 'neptune': 'neptune',
            'pluto': 'pluto', 'chiron': 'chiron',
            'true_node': 'true_node', 'mean_node': 'mean_node',
            'mean_lilith': 'mean_lilith', 'true_lilith': 'true_lilith',
        }
        attr = attr_map.get(planet_name.lower(), planet_name.lower())
        obj = getattr(subject, attr, None)

        if obj:
            return obj

        # Try asteroids via Swiss Ephemeris
        if planet_name.lower() in self.ASTEROIDS:
            body_num = self.ASTEROIDS[planet_name.lower()]
            return AsteroidObject.from_swisseph(
                planet_name,
                subject.julian_day,
                body_num
            )

        return None

    def _get_planet_position(self, subject, planet_name: str) -> tuple[str, str]:
        """Get (sign, house) for a planet. Extracted from _parse_aspects logic."""
        planet = self._get_planet_obj(subject, planet_name)
        if planet:
            sign = getattr(planet, 'sign', '')
            house = self._clean_house(getattr(planet, 'house', ''))
            return sign, house
        return '', ''

    def _clean_house(self, house: str) -> str:
        """Convert 'First_House' to '1'."""
        house_map = {
            'First_House': '1', 'Second_House': '2', 'Third_House': '3',
            'Fourth_House': '4', 'Fifth_House': '5', 'Sixth_House': '6',
            'Seventh_House': '7', 'Eighth_House': '8', 'Ninth_House': '9',
            'Tenth_House': '10', 'Eleventh_House': '11', 'Twelfth_House': '12',
        }
        return house_map.get(house, house)

    def compute_mundane_transits(self, date) -> list[TransitEvent]:
        """
        Compute mundane transits (transit-to-transit aspects) for a date.
        These are aspects between planets in the sky, without reference to a natal chart.
        """
        from kerykeion import AstrologicalSubject

        # Create a subject for the date at noon UTC
        # Use arbitrary location since we only care about ecliptic positions
        subject = AstrologicalSubject(
            "Transit", date.year, date.month, date.day, 12, 0,
            "London", "GB",
            houses_system_identifier="W",
            geonames_username=self.config.geonames_username
        )

        # Get all major planets
        planets = []
        for planet_name in ['Sun', 'Moon', 'Mercury', 'Venus', 'Mars',
                           'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto']:
            planet = self._get_planet_obj(subject, planet_name)
            if planet:
                planets.append((planet_name, planet))

        # Calculate aspects between all planet pairs
        aspects = []
        orb_settings = self.config.orb_settings

        for i, (name1, planet1) in enumerate(planets):
            for name2, planet2 in planets[i+1:]:
                # Calculate angular distance
                diff = abs(planet1.abs_pos - planet2.abs_pos)
                if diff > 180:
                    diff = 360 - diff

                # Check each aspect type
                for aspect_name, exact_angle in [
                    ('conjunction', 0),
                    ('opposition', 180),
                    ('trine', 120),
                    ('square', 90),
                    ('sextile', 60)
                ]:
                    orb_limit = orb_settings.get(aspect_name, 6)
                    aspect_diff = abs(diff - exact_angle)

                    # Handle conjunction wraparound
                    if aspect_name == 'conjunction':
                        aspect_diff = min(diff, 360 - diff)

                    if aspect_diff <= orb_limit:
                        # Calculate orb (positive = separating, negative = applying)
                        orb = diff - exact_angle
                        if aspect_name == 'conjunction':
                            orb = diff if diff < 180 else diff - 360

                        aspects.append(TransitEvent(
                            transit_planet=name1,
                            natal_planet=name2,  # Reusing field for second planet
                            aspect=aspect_name,
                            orb=orb,
                            transit_sign=planet1.sign,
                            transit_house='',
                            natal_sign=planet2.sign,
                            natal_house='',
                            applying=orb < 0
                        ))

        return aspects

    def forecast_mundane_transits(self, days: int, orb_limit: float = 1.0,
                                  start_date: Optional[datetime] = None,
                                  major_only: bool = True) -> list[tuple[str, list[TransitEvent]]]:
        """
        Forecast mundane transits for N days.
        Returns list of (date_str, events) tuples.
        """
        results = []
        today = start_date.date() if start_date else datetime.now().date()

        # Define major planets for filtering
        major_planets = {'Sun', 'Moon', 'Mars', 'Jupiter', 'Saturn',
                        'Uranus', 'Neptune', 'Pluto'}

        for day_offset in range(days):
            date = today + timedelta(days=day_offset)
            date_str = date.isoformat()

            # Compute mundane transits for this day
            events = self.compute_mundane_transits(date)

            # Filter to highlights
            highlights = []
            for e in events:
                if abs(e.orb) > orb_limit:
                    continue
                if major_only:
                    # At least one planet should be outer (Jupiter+)
                    outer_planets = {'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto'}
                    if not (e.transit_planet in outer_planets or e.natal_planet in outer_planets):
                        continue
                highlights.append(e)

            # Check for lunar phases
            lunar = self.get_lunar_phase(date, BirthData(
                full_name="", year=2000, month=1, day=1,
                hour=0, minute=0, city="London", nation="GB"
            ))
            if lunar:
                highlights.insert(0, lunar)

            if highlights:
                results.append((date_str, highlights))

        return results

    def _parse_aspects(self, raw_aspects: list, transit_subj, natal_subj) -> list[TransitEvent]:
        """Convert kerykeion aspects to TransitEvent objects."""
        events = []

        # Build lookup for planet data
        def get_planet_data(subj, name):
            """Get sign/house for a planet by name."""
            # Map common names to attribute names
            attr_map = {
                'Sun': 'sun', 'Moon': 'moon', 'Mercury': 'mercury',
                'Venus': 'venus', 'Mars': 'mars', 'Jupiter': 'jupiter',
                'Saturn': 'saturn', 'Uranus': 'uranus', 'Neptune': 'neptune',
                'Pluto': 'pluto', 'Chiron': 'chiron',
                'Ceres': 'ceres', 'Pallas': 'pallas', 'Juno': 'juno', 'Vesta': 'vesta',
                'True_North_Lunar_Node': 'true_north_lunar_node',
                'True_South_Lunar_Node': 'true_south_lunar_node',
                'Mean_Lilith': 'mean_lilith',
            }
            attr = attr_map.get(name, name.lower())
            planet = getattr(subj, attr, None)
            if planet:
                # Clean up house name (e.g., "Eighth_House" -> "8")
                house = getattr(planet, 'house', '')
                if house:
                    house_map = {
                        'First_House': '1', 'Second_House': '2', 'Third_House': '3',
                        'Fourth_House': '4', 'Fifth_House': '5', 'Sixth_House': '6',
                        'Seventh_House': '7', 'Eighth_House': '8', 'Ninth_House': '9',
                        'Tenth_House': '10', 'Eleventh_House': '11', 'Twelfth_House': '12',
                    }
                    house = house_map.get(house, house)
                return getattr(planet, 'sign', ''), house
            return '', ''

        for asp in raw_aspects:
            t_sign, t_house = get_planet_data(transit_subj, asp['p1_name'])
            n_sign, n_house = get_planet_data(natal_subj, asp['p2_name'])

            events.append(TransitEvent(
                transit_planet=asp['p1_name'],
                natal_planet=asp['p2_name'],
                aspect=asp['aspect'],
                orb=asp['orbit'],
                transit_sign=t_sign,
                transit_house=t_house,
                natal_sign=n_sign,
                natal_house=n_house,
                applying=True  # TODO: calculate applying/separating
            ))
        return events


# =============================================================================
# Transit Formatter
# =============================================================================

class TransitFormatter:
    """Formats transit data for display."""

    # Aspect symbols
    ASPECT_SYMBOLS = {
        'conjunction': 'â˜Œ',
        'opposition': 'â˜',
        'trine': 'â–³',
        'square': 'â–¡',
        'sextile': 'âš¹',
        'quincunx': 'âš»',
        'semisextile': 'âšº',
    }

    # Planet symbols
    PLANET_SYMBOLS = {
        'Sun': 'â˜‰',
        'Moon': 'â˜½',
        'Mercury': 'â˜¿',
        'Venus': 'â™€',
        'Mars': 'â™‚',
        'Jupiter': 'â™ƒ',
        'Saturn': 'â™„',
        'Uranus': 'â™…',
        'Neptune': 'â™†',
        'Pluto': 'â™‡',
        'Chiron': 'âš·',
        'Ceres': 'âš³',
        'Pallas': 'âš´',
        'Juno': 'âšµ',
        'Vesta': 'âš¶',
    }

    # Sign symbols
    SIGN_SYMBOLS = {
        'Ari': 'â™ˆ', 'Tau': 'â™‰', 'Gem': 'â™Š', 'Can': 'â™‹',
        'Leo': 'â™Œ', 'Vir': 'â™', 'Lib': 'â™Ž', 'Sco': 'â™',
        'Sag': 'â™', 'Cap': 'â™‘', 'Aqu': 'â™’', 'Pis': 'â™“',
    }

    def _sign_str(self, sign: str, house: str) -> str:
        """Format sign and house as compact string."""
        s_sym = self.SIGN_SYMBOLS.get(sign, sign)
        if house:
            return f"{s_sym}{house}"
        return s_sym

    def format_compact(self, transits: list[TransitEvent], limit: int = 15) -> str:
        """Compact format for current transits."""
        if not transits:
            return "No significant transits found."

        lines = []
        sorted_transits = sorted(transits, key=lambda x: abs(x.orb))[:limit]

        for t in sorted_transits:
            # Get symbols
            t_sym = self.PLANET_SYMBOLS.get(t.transit_planet, '')
            n_sym = self.PLANET_SYMBOLS.get(t.natal_planet, '')
            a_sym = self.ASPECT_SYMBOLS.get(t.aspect.lower(), '')

            orb_str = f"{t.orb:+.2f}Â°" if t.orb >= 0 else f"{t.orb:.2f}Â°"
            t_pos = self._sign_str(t.transit_sign, t.transit_house)
            n_pos = self._sign_str(t.natal_sign, t.natal_house)

            lines.append(
                f"  {t_sym} {t.transit_planet:8s} {t_pos:4s}  {a_sym} {t.aspect:10s}  "
                f"{n_sym} natal {t.natal_planet:8s} {n_pos:4s}  ({orb_str})"
            )

        return "\n".join(lines)

    def format_forecast(self, forecast: list[tuple[str, list[TransitEvent]]]) -> str:
        """Format forecast with dates and transits."""
        if not forecast:
            return "No exact transits in forecast period."

        lines = []
        for date_str, events in forecast:
            # Parse and format date
            date = datetime.fromisoformat(date_str)
            date_fmt = date.strftime("%a %b %d")

            lines.append(f"\n{date_fmt}:")
            for t in sorted(events, key=lambda x: abs(x.orb)):
                # Lunar phases (New Moon, Full Moon)
                if t.transit_planet in ('New Moon', 'Full Moon'):
                    phase_sym = 'ðŸŒ‘' if t.transit_planet == 'New Moon' else 'ðŸŒ•'
                    s_sym = self.SIGN_SYMBOLS.get(t.transit_sign, t.transit_sign)
                    lines.append(f"  {phase_sym} {t.transit_planet} in {s_sym} {t.transit_sign}")
                    continue

                t_sym = self.PLANET_SYMBOLS.get(t.transit_planet, '')
                n_sym = self.PLANET_SYMBOLS.get(t.natal_planet, '')
                a_sym = self.ASPECT_SYMBOLS.get(t.aspect.lower(), '')
                t_pos = self._sign_str(t.transit_sign, t.transit_house)
                n_pos = self._sign_str(t.natal_sign, t.natal_house)

                lines.append(
                    f"  {t_sym} {t.transit_planet:8s} {t_pos:4s} {a_sym} {t.aspect:10s} "
                    f"{n_sym} natal {t.natal_planet:8s} {n_pos:4s} ({t.orb:+.2f}Â°)"
                )

        return "\n".join(lines)

    def format_mundane(self, forecast: list[tuple[str, list[TransitEvent]]]) -> str:
        """Format mundane transits (transit-to-transit aspects) with dates."""
        if not forecast:
            return "No exact mundane transits in forecast period."

        lines = []
        for date_str, events in forecast:
            # Parse and format date
            date = datetime.fromisoformat(date_str)
            date_fmt = date.strftime("%a %b %d")

            lines.append(f"\n{date_fmt}:")
            for t in sorted(events, key=lambda x: abs(x.orb)):
                # Lunar phases (New Moon, Full Moon)
                if t.transit_planet in ('New Moon', 'Full Moon'):
                    phase_sym = 'ðŸŒ‘' if t.transit_planet == 'New Moon' else 'ðŸŒ•'
                    s_sym = self.SIGN_SYMBOLS.get(t.transit_sign, t.transit_sign)
                    lines.append(f"  {phase_sym} {t.transit_planet} in {s_sym} {t.transit_sign}")
                    continue

                # For mundane transits, show Planet1 aspect Planet2
                p1_sym = self.PLANET_SYMBOLS.get(t.transit_planet, '')
                p2_sym = self.PLANET_SYMBOLS.get(t.natal_planet, '')  # Reusing field
                a_sym = self.ASPECT_SYMBOLS.get(t.aspect.lower(), '')

                # Get sign symbols (no houses for mundane)
                p1_sign_sym = self.SIGN_SYMBOLS.get(t.transit_sign, t.transit_sign)
                p2_sign_sym = self.SIGN_SYMBOLS.get(t.natal_sign, t.natal_sign)

                lines.append(
                    f"  {p1_sym} {t.transit_planet:8s} {p1_sign_sym:2s} {a_sym} {t.aspect:10s} "
                    f"{p2_sym} {t.natal_planet:8s} {p2_sign_sym:2s} ({t.orb:+.2f}Â°)"
                )

        return "\n".join(lines)

    def format_planet_summary(self, planet_name: str, events: list[PlanetTrackingEvent],
                             start_date: datetime, end_date: datetime,
                             natal_chart: NatalChart) -> str:
        """Format summary statistics for planet tracking."""
        if not events:
            return f"No events found for {planet_name} in date range."

        # Group events by type
        sign_changes = [e for e in events if e.event_type == 'sign_change']
        house_changes = [e for e in events if e.event_type == 'house_change']
        stations_retro = [e for e in events if e.event_type == 'station_retrograde']
        stations_direct = [e for e in events if e.event_type == 'station_direct']
        aspects = [e for e in events if e.event_type == 'aspect']

        # Current vs starting position
        starting = events[0]
        current = events[-1]

        # Format retrograde periods
        retro_periods = []
        for i, retro_station in enumerate(stations_retro):
            # Find corresponding direct station
            direct_station = None
            for d_station in stations_direct:
                if d_station.date > retro_station.date:
                    direct_station = d_station
                    break

            if direct_station:
                retro_periods.append(f"  {retro_station.date} to {direct_station.date}")
            else:
                retro_periods.append(f"  {retro_station.date} onwards (still retrograde)")

        retro_text = "\n".join(retro_periods) if retro_periods else "  None"

        # Count major aspects (extract base aspect type)
        def base_aspect(a):
            return a.aspect.split(' (')[0]

        major_aspects = [a for a in aspects if base_aspect(a) in ['conjunction', 'opposition', 'trine', 'square']]

        planet_sym = self.PLANET_SYMBOLS.get(planet_name.title(), planet_name)
        sign_sym = self.SIGN_SYMBOLS.get(starting.sign, starting.sign)
        curr_sign_sym = self.SIGN_SYMBOLS.get(current.sign, current.sign)

        return f"""
{planet_sym} {planet_name.upper()} Tracking
Period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')} ({(end_date - start_date).days} days)
Chart: {natal_chart.birth_data.full_name}

Position:
  Starting: {sign_sym} {starting.sign} (house {starting.house})
  Current:  {curr_sign_sym} {current.sign} (house {current.house})

Activity Summary:
  Sign changes:        {len(sign_changes)}
  House transits:      {len(house_changes)}
  Retrograde stations: {len(stations_retro)}
  Direct stations:     {len(stations_direct)}
  Major aspects:       {len(major_aspects)} (conjunction/opposition/trine/square)
  All aspects:         {len(aspects)}

Retrograde Periods:
{retro_text}
"""

    def format_planet_timeline(self, events: list[PlanetTrackingEvent],
                              group_by: str = 'month') -> str:
        """Format detailed chronological timeline."""
        if not events:
            return ""

        lines = []

        if group_by == 'month':
            # Group by year-month
            from itertools import groupby

            for year_month, month_events in groupby(events, key=lambda e: e.date[:7]):
                # Parse year-month
                year, month = year_month.split('-')
                month_name = datetime(int(year), int(month), 1).strftime('%B')

                lines.append(f"\n{month_name} {year}:")

                for event in month_events:
                    lines.append(self._format_event(event))

        elif group_by == 'year':
            from itertools import groupby

            for year, year_events in groupby(events, key=lambda e: e.date[:4]):
                lines.append(f"\n{year}:")

                for event in year_events:
                    lines.append(self._format_event(event))

        elif group_by == 'type':
            from itertools import groupby

            # Sort by type then date
            sorted_events = sorted(events, key=lambda e: (e.event_type, e.date))

            for event_type, type_events in groupby(sorted_events, key=lambda e: e.event_type):
                lines.append(f"\n{event_type.replace('_', ' ').title()}:")

                for event in type_events:
                    lines.append(self._format_event(event))

        return "\n".join(lines)

    def _format_event(self, event: PlanetTrackingEvent) -> str:
        """Format a single planet tracking event."""
        date = datetime.fromisoformat(event.date).strftime('%m-%d')
        planet_sym = self.PLANET_SYMBOLS.get(event.planet.title(), event.planet)

        # Helper to convert absolute degree to sign-relative degree
        def deg_in_sign(abs_deg):
            return abs_deg % 30 if abs_deg else 0

        if event.event_type == 'sign_change':
            from_sym = self.SIGN_SYMBOLS.get(event.from_sign, event.from_sign)
            to_sym = self.SIGN_SYMBOLS.get(event.to_sign, event.to_sign)
            deg_info = f" at {deg_in_sign(event.degree):.1f}Â°" if event.degree else ""
            return f"  {date}: {planet_sym} enters {to_sym} {event.to_sign}{deg_info} (house {event.house})"

        elif event.event_type == 'house_change':
            sign_sym = self.SIGN_SYMBOLS.get(event.sign, event.sign)
            deg_info = f" at {deg_in_sign(event.degree):.1f}Â°" if event.degree else ""
            return f"  {date}: {planet_sym} enters house {event.to_house}{deg_info} (in {sign_sym} {event.sign})"

        elif event.event_type == 'station_retrograde':
            sign_sym = self.SIGN_SYMBOLS.get(event.sign, event.sign)
            return f"  {date}: {planet_sym} stations RETROGRADE at {deg_in_sign(event.degree):.1f}Â° {sign_sym} {event.sign}"

        elif event.event_type == 'station_direct':
            sign_sym = self.SIGN_SYMBOLS.get(event.sign, event.sign)
            return f"  {date}: {planet_sym} stations DIRECT at {deg_in_sign(event.degree):.1f}Â° {sign_sym} {event.sign}"

        elif event.event_type == 'aspect':
            natal_sym = self.PLANET_SYMBOLS.get(event.natal_planet, event.natal_planet)

            # Extract base aspect type and transition marker
            aspect_parts = event.aspect.split(' (')
            base_aspect = aspect_parts[0]
            transition = f" ({aspect_parts[1]}" if len(aspect_parts) > 1 else ""

            aspect_sym = self.ASPECT_SYMBOLS.get(base_aspect.lower(), base_aspect)
            sign_sym = self.SIGN_SYMBOLS.get(event.sign, event.sign)
            deg_info = f" at {deg_in_sign(event.degree):.1f}Â°" if event.degree else ""

            return (f"  {date}: {planet_sym}{deg_info} {aspect_sym} {base_aspect}{transition} "
                    f"{natal_sym} natal {event.natal_planet} ({event.orb:+.2f}Â°)")

        return f"  {date}: {event.event_type}"


# =============================================================================
# CLI
# =============================================================================

def parse_timeline_args(args) -> tuple[datetime, datetime]:
    """
    Parse timeline arguments into start_date, end_date.

    Priority:
    1. --from/--to (explicit dates)
    2. --past/--future (months from now)
    3. Default: 12 months past, 12 months future
    """
    now = datetime.now()

    # Explicit date range
    if hasattr(args, 'from_date') and args.from_date:
        start = datetime.strptime(args.from_date, "%Y-%m-%d")
    elif hasattr(args, 'past') and args.past:
        start = now - timedelta(days=args.past * 30)
    else:
        start = now - timedelta(days=365)  # Default: 12 months back

    if hasattr(args, 'to_date') and args.to_date:
        end = datetime.strptime(args.to_date, "%Y-%m-%d")
    elif hasattr(args, 'future') and args.future:
        end = now + timedelta(days=args.future * 30)
    else:
        end = now + timedelta(days=365)  # Default: 12 months forward

    return start, end


def main():
    parser = argparse.ArgumentParser(
        prog='astro',
        description='Astrological transit tracker',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  astro add-chart                # Add default natal chart
  astro add-chart partner        # Add chart named 'partner'
  astro now                      # Current transits (default chart)
  astro now partner              # Current transits for partner
  astro forecast --days 30       # 30-day forecast from today
  astro forecast --date 2025-06-01 --days 30  # Forecast from June 1st
  astro mundane --days 30        # Mundane transits (transit-to-transit)
  astro list-charts              # Show all saved charts
"""
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # --- Chart management ---
    add_p = subparsers.add_parser('add-chart', help='Add natal chart interactively')
    add_p.add_argument('name', nargs='?', help='Chart name (default: "default")')

    subparsers.add_parser('list-charts', help='List all saved charts')

    show_p = subparsers.add_parser('show-chart', help='Show chart details')
    show_p.add_argument('name', nargs='?', help='Chart name (uses config default)')

    rm_p = subparsers.add_parser('remove-chart', help='Remove a chart')
    rm_p.add_argument('name', help='Chart name to remove')

    # --- Transit queries ---
    now_p = subparsers.add_parser('now', help='Show current transits')
    now_p.add_argument('chart', nargs='?', help='Chart name (uses config default)')

    fc_p = subparsers.add_parser('forecast', help='Forecast upcoming transits')
    fc_p.add_argument('chart', nargs='?', help='Chart name (uses config default)')
    fc_p.add_argument('--days', '-d', type=int, default=30, help='Days to forecast (default: 30)')
    fc_p.add_argument('--date', type=str, help='Start date (YYYY-MM-DD, default: today)')
    fc_p.add_argument('--all', '-a', action='store_true', help='Include all objects (nodes, chiron, etc.)')
    fc_p.add_argument('--orb', '-o', type=float, default=0.5, help='Max orb in degrees (default: 0.5)')

    # --- Mundane transits ---
    mundane_p = subparsers.add_parser('mundane', help='Mundane transits (transit-to-transit aspects)')
    mundane_p.add_argument('--days', '-d', type=int, default=30, help='Days to forecast (default: 30)')
    mundane_p.add_argument('--date', type=str, help='Start date (YYYY-MM-DD, default: today)')
    mundane_p.add_argument('--all', '-a', action='store_true', help='Include all planets (not just outer)')
    mundane_p.add_argument('--orb', '-o', type=float, default=1.0, help='Max orb in degrees (default: 1.0)')

    # --- Planet tracking ---
    planet_p = subparsers.add_parser('planet', help='Track single planet over time',
                                     epilog='''
Examples:
  astro planet chiron                    # 12 months past + 12 months future (default)
  astro planet mercury --past 24 --future 12  # 24 months back, 12 forward
  astro planet venus --from 2023-01-01 --to 2025-12-31  # Explicit range
  astro planet mars --summary-only       # Just statistics, no timeline
  astro planet jupiter --no-aspects      # Ingresses and stations only
''')
    planet_p.add_argument('name', help='Planet name (mars, venus, chiron, etc.)')
    planet_p.add_argument('chart', nargs='?', help='Chart name (uses config default)')

    # Timeline options
    timeline_g = planet_p.add_argument_group('timeline options')
    timeline_g.add_argument('--past', type=int, help='Months in past')
    timeline_g.add_argument('--future', type=int, help='Months in future')
    timeline_g.add_argument('--from', dest='from_date', type=str,
                           help='Start date (YYYY-MM-DD)')
    timeline_g.add_argument('--to', dest='to_date', type=str,
                           help='End date (YYYY-MM-DD)')

    # Display options
    display_g = planet_p.add_argument_group('display options')
    display_g.add_argument('--no-aspects', action='store_true',
                          help='Exclude aspects (faster)')
    display_g.add_argument('--aspect-orb', type=float, default=1.0,
                          help='Max aspect orb in degrees (default: 1.0)')
    display_g.add_argument('--group-by', choices=['month', 'year', 'type'],
                          default='month', help='Timeline grouping')
    display_g.add_argument('--summary-only', action='store_true',
                          help='Show summary only, no timeline')

    # --- Utility ---
    subparsers.add_parser('clear-cache', help='Clear transit cache')
    subparsers.add_parser('config', help='Show configuration')

    args = parser.parse_args()

    # Initialize components
    storage = AstroStorage()
    config = storage.load_config()
    chart_mgr = ChartManager(storage)
    transit_calc = TransitCalculator(storage)
    formatter = TransitFormatter()

    # Helper to get chart name with config default
    def get_chart_name(arg_value):
        return arg_value if arg_value else config.default_chart

    # --- Dispatch commands ---

    if args.command == 'add-chart':
        chart = chart_mgr.create_chart_interactive(args.name)
        print()
        print(f"Chart '{chart.name}' saved successfully.")

    elif args.command == 'list-charts':
        charts = storage.list_charts()
        if charts:
            config = storage.load_config()
            print("Saved charts:")
            for name in charts:
                marker = " (default)" if name == config.default_chart else ""
                print(f"  - {name}{marker}")
        else:
            print("No charts found.")
            print("Run 'astro add-chart' to create one.")

    elif args.command == 'show-chart':
        try:
            chart = storage.load_chart(get_chart_name(args.name))
            bd = chart.birth_data
            print(f"Chart: {chart.name}")
            print(f"  Name:     {bd.full_name}")
            print(f"  Birth:    {bd.year}-{bd.month:02d}-{bd.day:02d} "
                  f"{bd.hour:02d}:{bd.minute:02d}")
            print(f"  Location: {bd.city}, {bd.nation}")
            print(f"  Created:  {chart.created_at[:10]}")
        except FileNotFoundError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    elif args.command == 'remove-chart':
        if storage.delete_chart(args.name):
            print(f"Removed chart: {args.name}")
        else:
            print(f"Error: Chart '{args.name}' not found", file=sys.stderr)
            sys.exit(1)

    elif args.command == 'now':
        try:
            chart = storage.load_chart(get_chart_name(args.chart))
            now = datetime.now()
            print(f"Transits for {chart.birth_data.full_name}")
            print(f"({now.strftime('%Y-%m-%d %H:%M')})")
            print()
            transits = transit_calc.compute_current_transits(chart)
            print(formatter.format_compact(transits))
        except FileNotFoundError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    elif args.command == 'forecast':
        try:
            chart = storage.load_chart(get_chart_name(args.chart))
            major_only = not args.all
            obj_desc = "all objects" if args.all else "major planets"

            # Parse start date if provided
            start_date = None
            if args.date:
                try:
                    start_date = datetime.strptime(args.date, "%Y-%m-%d")
                except ValueError:
                    print(f"Error: Invalid date format '{args.date}'. Use YYYY-MM-DD.", file=sys.stderr)
                    sys.exit(1)

            start_str = start_date.strftime("%Y-%m-%d") if start_date else "today"
            print(f"{args.days}-day forecast for {chart.birth_data.full_name}")
            print(f"(from {start_str}, orb < {args.orb}Â°, {obj_desc})")
            forecast = transit_calc.forecast_transits(
                chart, args.days, orb_limit=args.orb, major_only=major_only,
                start_date=start_date
            )
            print(formatter.format_forecast(forecast))
        except FileNotFoundError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    elif args.command == 'mundane':
        major_only = not args.all
        obj_desc = "all planets" if args.all else "outer planets"

        # Parse start date if provided
        start_date = None
        if args.date:
            try:
                start_date = datetime.strptime(args.date, "%Y-%m-%d")
            except ValueError:
                print(f"Error: Invalid date format '{args.date}'. Use YYYY-MM-DD.", file=sys.stderr)
                sys.exit(1)

        start_str = start_date.strftime("%Y-%m-%d") if start_date else "today"
        print(f"{args.days}-day mundane transit forecast")
        print(f"(from {start_str}, orb < {args.orb}Â°, {obj_desc})")
        forecast = transit_calc.forecast_mundane_transits(
            args.days, orb_limit=args.orb, start_date=start_date,
            major_only=major_only
        )
        print(formatter.format_mundane(forecast))

    elif args.command == 'planet':
        try:
            # Validate planet name
            valid_planets = {
                'sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn',
                'uranus', 'neptune', 'pluto', 'chiron',
                'ceres', 'pallas', 'juno', 'vesta',  # Asteroids via Swiss Ephemeris
                'true_node', 'mean_lilith'
            }
            planet_name = args.name.lower()

            if planet_name not in valid_planets:
                print(f"Error: Unknown planet '{args.name}'", file=sys.stderr)
                print(f"Valid: {', '.join(sorted(valid_planets))}", file=sys.stderr)
                sys.exit(1)

            # Load chart
            chart = storage.load_chart(get_chart_name(args.chart))

            # Parse timeline
            start_date, end_date = parse_timeline_args(args)

            # Validate date range
            days = (end_date - start_date).days
            if days > 1095:  # 3 years
                print(f"Warning: {days} days is a large range. First run may be slow.",
                      file=sys.stderr)

            # Track planet
            print(f"Tracking {planet_name}...", file=sys.stderr)
            events = transit_calc.track_planet(
                chart,
                planet_name,
                start_date,
                end_date,
                include_aspects=not args.no_aspects,
                aspect_orb=args.aspect_orb
            )

            # Display results
            print(formatter.format_planet_summary(
                planet_name, events, start_date, end_date, chart
            ))

            if not args.summary_only:
                print("\nDetailed Timeline:")
                print("=" * 60)
                print(formatter.format_planet_timeline(events, group_by=args.group_by))

        except FileNotFoundError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    elif args.command == 'clear-cache':
        count = storage.clear_cache()
        print(f"Cleared {count} cached transit files.")

    elif args.command == 'config':
        config = storage.load_config()
        print(f"Data directory: {storage.base_path}")
        print(f"Default chart:  {config.default_chart}")
        print(f"Display format: {config.display_format}")
        print(f"Orb settings:")
        for aspect, orb in config.orb_settings.items():
            print(f"  {aspect}: {orb}Â°")

    else:
        parser.print_help()


if __name__ == '__main__':
    main()
