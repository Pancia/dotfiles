#!/usr/bin/env ruby

require "cli.rb"

require "shellwords"

$home_dir = "/Users/#{%x[whoami].strip}/"
$services_dir = "#{$home_dir}/dotfiles/services/"
$log_dir = "#{$home_dir}/.log/services/"
$launch_agents_dir = "#{$home_dir}/Library/LaunchAgents/"

def log_for(name)
  "#{$log_dir}#{name}.log"
end

def normalize_service_name(name)
  # Accept "vpc" or "org.pancia.vpc"
  name.start_with?("org.pancia.") ? name : "org.pancia.#{name}"
end

def short_name(full_name)
  full_name.sub("org.pancia.", "")
end

def plist_path_in_services(name)
  short = short_name(name)
  "#{$services_dir}#{short}/#{name}.plist"
end

def plist_path_in_launch_agents(name)
  "#{$launch_agents_dir}#{name}.plist"
end

def service_dir(name)
  short = short_name(name)
  "#{$services_dir}#{short}/"
end

def detect_main_script(name)
  dir = service_dir(name)
  # Prefer script.sh, then other common script files
  candidates = ["script.sh", "server.rb", "listener.rb", "listener.swift", "script.py"]
  candidates.each do |candidate|
    path = "#{dir}#{candidate}"
    return path if File.exist?(path)
  end
  # Fallback to any .sh, .rb, .swift, .py file
  Dir.glob("#{dir}*.{sh,rb,swift,py}").first
end

def execute(cmd)
  puts cmd if $options[:verbose]
  system(cmd)
end

class ServiceCMDS
  def self.list(opts)
    opts.info = "List my services"
    lambda { execute("launchctl list | ag org.pancia") }
  end
  def self.start(opts)
    opts.info = "Start a service."
    lambda { |name|
      return puts "Usage: service start <name>" unless name

      full_name = normalize_service_name(name)
      plist_dest = plist_path_in_launch_agents(full_name)

      # Try to install if not present (fallback)
      unless File.exist?(plist_dest)
        plist_src = plist_path_in_services(full_name)
        if File.exist?(plist_src)
          puts "Installing #{full_name}..."
          execute("ln -f #{plist_src.shellescape} #{plist_dest.shellescape}")
        else
          return puts "Error: Service '#{name}' not found in #{$services_dir}"
        end
      end

      puts "Loading #{full_name}..."
      execute("launchctl load #{plist_dest.shellescape}")
      execute("launchctl start #{full_name.shellescape}")
      puts "Started #{full_name}"
    }
  end
  def self.stop(opts)
    opts.info = "Stop a service."
    lambda { |name|
      return puts "Usage: service stop <name>" unless name

      full_name = normalize_service_name(name)
      plist_dest = plist_path_in_launch_agents(full_name)

      unless File.exist?(plist_dest)
        return puts "Error: Service '#{name}' is not installed"
      end

      puts "Stopping #{full_name}..."
      execute("launchctl stop #{full_name.shellescape}")
      execute("launchctl unload #{plist_dest.shellescape}")
      puts "Stopped #{full_name}"
    }
  end
  def self.restart(opts)
    opts.info = "Restart a service."
    lambda { |name, *args|
      return puts "Usage: service restart <name> [--log]" unless name

      # Check for --log flag in remaining arguments
      open_log = args.include?("--log") || args.include?("-l")

      full_name = normalize_service_name(name)
      plist_dest = plist_path_in_launch_agents(full_name)

      unless File.exist?(plist_dest)
        return puts "Error: Service '#{name}' is not installed"
      end

      puts "Restarting #{full_name}..."
      execute("launchctl stop #{full_name.shellescape}")
      execute("launchctl unload #{plist_dest.shellescape}")
      sleep 0.5
      execute("launchctl load #{plist_dest.shellescape}")
      execute("launchctl start #{full_name.shellescape}")
      puts "Restarted #{full_name}"

      if open_log
        short = short_name(full_name)
        Kernel.exec("command less +GF #{log_for(short)}")
      end
    }
  end
  def self.status(opts)
    opts.info = "status of all services"
    lambda {
      output = %x[launchctl list | grep org.pancia]
      if output.empty?
        puts "No org.pancia services found"
      else
        puts "%-30s %-10s %s" % ["SERVICE", "PID", "STATUS"]
        puts "-" * 60
        output.each_line do |line|
          parts = line.strip.split(/\s+/)
          pid = parts[0] == "-" ? "not running" : parts[0]
          exit_code = parts[1]
          name = parts[2].sub("org.pancia.", "")
          status = pid == "not running" ? "stopped" : (exit_code == "0" ? "running" : "error (#{exit_code})")
          puts "%-30s %-10s %s" % [name, pid, status]
        end
      end
    }
  end
  def self.log(opts)
    opts.info = "Show the logs for a service."
    lambda { |name|
      return puts "Usage: service log <name>" unless name
      full_name = normalize_service_name(name)
      short = short_name(full_name)
      # Become that process, so we can  to stop +F paging & look around with less
      Kernel.exec("command less +GF #{log_for(short)}")
    }
  end
  def self.create(opts)
    opts.info = "Create a new service."
    lambda { |name|
      return puts "Usage: service create <name>" unless name

      full_name = normalize_service_name(name)
      short = short_name(full_name)
      dir = service_dir(full_name)

      if Dir.exist?(dir)
        return puts "Error: Service '#{short}' already exists at #{dir}"
      end

      puts "Creating service '#{short}'..."

      # Create directory
      execute("mkdir -p #{dir.shellescape}")

      # Create plist
      plist_content = <<~PLIST
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
            <dict>
                <key>Label</key>
                <string>#{full_name}</string>
                <key>ProgramArguments</key>
                <array>
                    <string>#{$home_dir}dotfiles/services/#{short}/dotfiles-services-#{short}.sh</string>
                </array>
                <key>RunAtLoad</key>
                <true/>
                <key>KeepAlive</key>
                <true/>
                <key>StandardOutPath</key>
                <string>#{$home_dir}.log/services/#{short}.log</string>
                <key>StandardErrorPath</key>
                <string>#{$home_dir}.log/services/#{short}.log</string>
            </dict>
        </plist>
      PLIST
      File.write("#{dir}#{full_name}.plist", plist_content)

      # Create wrapper script
      wrapper_content = "~/dotfiles/bin/service-wrapper ~/dotfiles/services/#{short}/ ./script.sh\n"
      File.write("#{dir}dotfiles-services-#{short}.sh", wrapper_content)
      execute("chmod +x #{dir}dotfiles-services-#{short}.sh")

      # Create main script
      script_content = <<~SCRIPT
        #!/usr/bin/env bash

        echo "$(date): #{short} service started"

        # Your service logic here
        while true; do
            echo "$(date): Running..."
            sleep 60
        done
      SCRIPT
      File.write("#{dir}script.sh", script_content)
      execute("chmod +x #{dir}script.sh")

      puts "Created service '#{short}' at #{dir}"
      puts "  - #{full_name}.plist"
      puts "  - dotfiles-services-#{short}.sh"
      puts "  - script.sh"
      puts ""
      puts "Next steps:"
      puts "  1. Edit: service edit #{short}"
      puts "  2. Start: service start #{short}"
      puts "  3. Logs: service log #{short}"
    }
  end
  def self.edit(opts)
    opts.info = "Edit a service's script and plist."
    lambda { |name|
      return puts "Usage: service edit <name>" unless name

      full_name = normalize_service_name(name)
      short = short_name(full_name)
      dir = service_dir(full_name)

      unless Dir.exist?(dir)
        return puts "Error: Service '#{short}' not found at #{dir}"
      end

      script = detect_main_script(full_name)
      plist = plist_path_in_services(full_name)

      unless script
        return puts "Error: No main script found in #{dir}"
      end

      unless File.exist?(plist)
        return puts "Error: Plist not found at #{plist}"
      end

      editor = ENV["EDITOR"] || "vim"
      puts "Opening #{short} in #{editor}..."
      Kernel.exec("#{editor} #{script.shellescape} #{plist.shellescape}")
    }
  end
end

CLI.parse! ServiceCMDS
