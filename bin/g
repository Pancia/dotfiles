#!/usr/bin/env python3
"""Git which-key modal menu - single-key navigation for git commands."""
import sys
import os
import tty
import termios
import subprocess

# ANSI colors
BOLD_CYAN = '\033[1;96m'
BOLD_WHITE = '\033[1;37m'
BOLD_YELLOW = '\033[1;93m'
YELLOW = '\033[33m'
DIM = '\033[2;37m'
RESET = '\033[0m'

# Menu structure - nested dicts are submenus, tuples are (description, command, stay_open)
# stay_open=True keeps modal open after command (for informational commands)
COMMANDS = {
    '_desc': 'Git',
    'a': {
        '_desc': 'Add',
        'f': ('Add file (fzf)', 'git ls-files -m -o --exclude-standard | fzf -m | xargs git add && git status', True),
        '.': ('Add this directory', 'git add . && git status', True),
        'a': ('Add all', 'git add --all && git status', True),
        'p': ('Add interactively', 'git add --patch && git status', True),
    },
    'b': ('Blame (fzf)', 'git ls-files | fzf | xargs git blame', True),
    'c': {
        '_desc': 'Commit',
        'c': ('Commit', 'git commit --verbose && git status', True),
        'a': ('Commit all', 'git commit --verbose --all && git status', True),
        'm': ('Amend', 'git commit --amend --verbose && git status', True),
        'p': ('Commit interactively', 'git commit --patch && git status', True),
        'i': ('Commit (AI message)', 'ai_git_commit && git status', True),
    },
    'd': {
        '_desc': 'Diff',
        'd': ('Diff', 'git diff --color-words', True),
        's': ('Diff staged', 'git diff --staged --color-words', True),
        'f': ('Diff file (fzf)', 'git ls-files -m | fzf | xargs -r git diff --color-words', True),
    },
    'f': {
        '_desc': 'Fetch/Pull',
        'f': ('Fetch all', 'git fetch --all --prune && git status', True),
        'l': ('Pull', 'git pull && git status', True),
    },
    'h': ('Show (last commit)', 'git show --color-words', True),
    'l': ('Log graph', 'git log --graph --all --decorate --abbrev-commit --oneline -20', True),
    'p': {
        '_desc': 'Push/Pull',
        'p': {
            '_desc': 'Push',
            'p': ('Push', 'git push && git status', True),
            'f': ('Push force++', 'git push --force-with-lease --force-if-includes && git status', True),
        },
        'l': ('Pull', 'git pull && git status', True),
    },
    'r': {
        '_desc': 'Restore',
        's': ('Unstage (fzf)', 'git diff --staged --name-only | fzf -m | xargs git restore --staged && git status', True),
        'r': ('Restore file (fzf)', 'git diff --name-only | fzf -m | xargs git restore && git status', True),
    },
    's': ('Status', 'git status', True),
    't': {
        '_desc': 'Stash',
        't': ('Stash', 'git stash && git status', True),
        's': ('Stash save (named)', 'git stash save && git status', True),
        'p': ('Stash pop', 'git stash pop && git status', True),
        'l': ('Stash list', 'git stash list', True),
    },
    'w': ('Switch branch (fzf)', 'git branch -a | fzf | xargs git checkout && git status', True),
    '=': ('Edit this menu', ['nvim', __file__, '-c', '/^COMMANDS', '-c', 'normal zt'], True, True),  # stay_open, reload
}


def getch():
    """Read a single character without echo."""
    fd = sys.stdin.fileno()
    if not os.isatty(fd):
        sys.exit(0)
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        return sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)


def print_menu(commands, path=''):
    """Display the menu with available commands."""
    entries = []

    for key, content in commands.items():
        if key.startswith('_'):
            continue
        if isinstance(content, tuple):
            desc = content[0]
            formatted = f"{BOLD_CYAN}[{key}]{RESET} {BOLD_WHITE}{desc}{RESET}"
            plain_len = len(f"[{key}] {desc}")
            entries.append((key, formatted, plain_len))
        else:
            desc = content.get('_desc', key)
            formatted = f"{BOLD_YELLOW}[{key}]{RESET} {YELLOW}→ {desc}{RESET}"
            plain_len = len(f"[{key}] → {desc}")
            entries.append((key, formatted, plain_len))

    entries.sort(key=lambda x: x[0].lower())

    if not entries:
        return

    # Get terminal width
    try:
        term_width = os.get_terminal_size().columns
    except OSError:
        term_width = 80

    # Calculate columns
    max_width = max(e[2] for e in entries) + 2
    num_cols = max(1, term_width // max_width)
    num_rows = (len(entries) + num_cols - 1) // num_cols

    # Print header
    menu_desc = commands.get('_desc', 'Git')
    if path:
        print(f"{DIM}{path}{RESET}{BOLD_WHITE}{menu_desc}{RESET}")
    else:
        print(f"{BOLD_WHITE}{menu_desc}{RESET}")
    print()

    # Print in columns
    for row in range(num_rows):
        line_parts = []
        for col in range(num_cols):
            idx = col * num_rows + row
            if idx < len(entries):
                _, formatted, plain_len = entries[idx]
                padding = ' ' * (max_width - plain_len)
                line_parts.append(formatted + padding)
        print(''.join(line_parts).rstrip())

    print()
    if path:
        print(f"{DIM}<DEL> Go back  <ESC> Exit{RESET}")
    else:
        print(f"{DIM}<ESC> Exit{RESET}")


def execute_command(command):
    """Execute a git command."""
    if isinstance(command, list):
        # Direct execution without shell
        print(f"{DIM}$ {' '.join(command)}{RESET}\n")
        subprocess.run(command)
    else:
        # Handle % as current file placeholder
        if '%' in command:
            print(f"{YELLOW}Note: '%' placeholder not available in shell (use in editor){RESET}")
            command = command.replace(' %', '')
        print(f"{DIM}$ {command}{RESET}\n")
        subprocess.run(command, shell=True, executable='/opt/homebrew/bin/fish')


def reload_commands():
    """Reload COMMANDS from this file."""
    global COMMANDS
    with open(__file__, 'r') as f:
        source = f.read()
    # Extract and exec just the COMMANDS definition
    exec(compile(source, __file__, 'exec'), globals())
    return COMMANDS


def main():
    current = COMMANDS
    history = []
    path = ''

    while True:
        print_menu(current, path)
        key = getch()

        if key in ('\x1b', '\x03', '\x04'):  # ESC, Ctrl-C, Ctrl-D
            break
        elif key in ('\x7f', '\x08'):  # DEL, Backspace
            if history:
                current, path = history.pop()
            else:
                break
        elif key in current:
            action = current[key]
            if isinstance(action, tuple):
                # Execute command - tuple is (desc, cmd, stay_open, reload)
                desc = action[0]
                cmd = action[1]
                stay_open = action[2] if len(action) > 2 else False
                should_reload = action[3] if len(action) > 3 else False
                execute_command(cmd)
                if should_reload:
                    current = reload_commands()
                    history = []
                    path = ''
                if not stay_open:
                    break
            else:
                # Enter submenu
                history.append((current, path))
                path = f"{path}{current.get('_desc', '')} → "
                current = action
        else:
            print(f"{YELLOW}Unknown key: {repr(key)}{RESET}\n")


if __name__ == '__main__':
    main()
