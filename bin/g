#!/usr/bin/env python3
"""Git which-key modal menu - single-key navigation for git commands."""
import sys
import os
import tty
import termios
import subprocess

# ANSI colors
BOLD_CYAN = '\033[1;96m'
BOLD_WHITE = '\033[1;37m'
BOLD_YELLOW = '\033[1;93m'
YELLOW = '\033[33m'
DIM = '\033[2;37m'
RESET = '\033[0m'
CYAN = '\033[36m'
GREEN = '\033[32m'
RED = '\033[31m'


def git_status_line():
    """Display git status line matching Tide prompt format."""
    def run(cmd):
        try:
            return subprocess.run(cmd, capture_output=True, text=True, timeout=2).stdout.strip()
        except:
            return ''

    # Branch name (or tag/SHA if detached)
    branch = run(['git', 'branch', '--show-current'])
    if not branch:
        # Detached HEAD - try tag, then short SHA
        branch = run(['git', 'describe', '--tags', '--exact-match', 'HEAD'])
        if branch:
            branch = '#' + branch
        else:
            branch = '@' + run(['git', 'rev-parse', '--short', 'HEAD'])
    if not branch or branch in ('@', '#'):
        return  # Not in a git repo

    # Status counts from porcelain
    status = run(['git', 'status', '--porcelain'])
    staged = dirty = untracked = conflicted = 0
    for line in status.splitlines():
        if line.startswith('UU'):
            conflicted += 1
        elif line[0] in 'ADMR':
            staged += 1
        if len(line) > 1 and line[1] in 'ADMR':
            dirty += 1
        if line.startswith('??'):
            untracked += 1

    # Stash count
    stash = len(run(['git', 'stash', 'list']).splitlines()) if run(['git', 'stash', 'list']) else 0

    # Ahead/behind upstream
    ahead = behind = 0
    upstream = run(['git', 'rev-list', '--count', '--left-right', '@{upstream}...HEAD'])
    if upstream and '\t' in upstream:
        behind, ahead = upstream.split('\t')
        behind, ahead = int(behind), int(ahead)

    # Choose background color like Tide: green=clean, yellow=unstable, red=urgent
    if conflicted:
        bg = '\033[41m'  # Red background
    elif staged or dirty or untracked:
        bg = '\033[43m'  # Yellow background
    else:
        bg = '\033[42m'  # Green background
    black = '\033[30m'  # Black text for contrast

    # Build status line - only show non-zero values
    parts = [branch]
    if behind:
        parts.append(f"⇣{behind}")
    if ahead:
        parts.append(f"⇡{ahead}")
    if stash:
        parts.append(f"*{stash}")
    if conflicted:
        parts.append(f"~{conflicted}")
    if staged:
        parts.append(f"+{staged}")
    if dirty:
        parts.append(f"!{dirty}")
    if untracked:
        parts.append(f"?{untracked}")

    print(f"{bg}{black} {' '.join(parts)} {RESET}")

# Menu structure - nested dicts are submenus, tuples are (description, command, stay_in_submenu)
# stay_in_submenu=True stays in current submenu, False goes back to root
COMMANDS = {
    '_desc': 'Git',
    'a': {
        '_desc': 'Add',
        'f': ('Add file (fzf)', 'git ls-files -m -o --exclude-standard | fzf -m | xargs git add && git status', True),
        '.': ('Add this directory', 'git add . && git status', True),
        'a': ('Add all', 'git add --all && git status'),
        'p': ('Add interactively', 'git add --patch && git status'),
    },
    'b': ('Blame (fzf)', 'git ls-files | fzf | xargs git blame'),
    'c': {
        '_desc': 'Commit',
        'c': ('Commit', 'git commit --verbose && git status'),
        'a': ('Commit all', 'git commit --verbose --all && git status'),
        'm': ('Amend', 'git commit --amend --verbose && git status'),
        'p': ('Commit interactively', 'git commit --patch && git status'),
        'i': ('Commit (AI message)', 'ai_git_commit && git status'),
        'I': ('Add all + AI commit', 'git add --all && ai_git_commit && git status'),
    },
    'd': {
        '_desc': 'Diff',
        'd': ('Diff', 'git diff --color-words', True),
        's': ('Diff staged', 'git diff --staged --color-words', True),
        'f': ('Diff file (fzf)', 'git ls-files -m | fzf | xargs git diff --color-words', True),
    },
    'f': {
        '_desc': 'Fetch/Pull',
        'f': ('Fetch all', 'git fetch --all --prune && git status'),
        'l': ('Pull', 'git pull && git status'),
    },
    'h': ('Show (last commit)', 'git show --color-words'),
    'l': ('Log graph', 'git log --graph --all --decorate --abbrev-commit'),
    'p': {
        '_desc': 'Push/Pull',
        'p': {
            '_desc': 'Push',
            'p': ('Push', 'git push && git status'),
            'f': ('Push force++', 'git push --force-with-lease --force-if-includes && git status'),
        },
        'l': ('Pull', 'git pull && git status'),
    },
    'r': {
        '_desc': 'Restore',
        's': ('Unstage (fzf)', 'git diff --staged --name-only | fzf -m | xargs git restore --staged && git status', True),
        'r': ('Restore file (fzf)', 'git diff --name-only | fzf -m | xargs git restore && git status', True),
    },
    's': ('Status', 'git status'),
    't': {
        '_desc': 'Stash',
        't': ('Stash', 'git stash && git status'),
        's': ('Stash save (named)', 'git stash save && git status'),
        'p': ('Stash pop', 'git stash pop && git status'),
        'l': ('Stash list', 'git stash list', True),
    },
    'w': ('Switch branch (fzf)', 'git branch -a | fzf | xargs git checkout && git status'),
    '=': ('Edit this menu', ['nvim', __file__, '-c', '/^COMMANDS', '-c', 'normal zt'], False, True),  # go to root, reload
}


def getch():
    """Read a single character without echo."""
    fd = sys.stdin.fileno()
    if not os.isatty(fd):
        sys.exit(0)
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        return sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)


def print_menu(commands, path=''):
    """Display the menu with available commands."""
    entries = []

    for key, content in commands.items():
        if key.startswith('_'):
            continue
        if isinstance(content, tuple):
            desc = content[0]
            formatted = f"{BOLD_CYAN}[{key}]{RESET} {BOLD_WHITE}{desc}{RESET}"
            plain_len = len(f"[{key}] {desc}")
            entries.append((key, formatted, plain_len))
        else:
            desc = content.get('_desc', key)
            formatted = f"{BOLD_YELLOW}[{key}]{RESET} {YELLOW}→ {desc}{RESET}"
            plain_len = len(f"[{key}] → {desc}")
            entries.append((key, formatted, plain_len))

    entries.sort(key=lambda x: x[0].lower())

    if not entries:
        return

    # Get terminal width
    try:
        term_width = os.get_terminal_size().columns
    except OSError:
        term_width = 80

    # Calculate columns
    max_width = max(e[2] for e in entries) + 2
    num_cols = max(1, term_width // max_width)
    num_rows = (len(entries) + num_cols - 1) // num_cols

    # Print separator and header
    print(f"{DIM}{'─' * 40}{RESET}")
    if path:
        menu_desc = commands.get('_desc', '')
        print(f"{DIM}{path}{RESET}{BOLD_WHITE}{menu_desc}{RESET}")
        print()

    # Print in columns
    for row in range(num_rows):
        line_parts = []
        for col in range(num_cols):
            idx = col * num_rows + row
            if idx < len(entries):
                _, formatted, plain_len = entries[idx]
                padding = ' ' * (max_width - plain_len)
                line_parts.append(formatted + padding)
        print(''.join(line_parts).rstrip())

    if path:
        print(f"{DIM}[:] Search  <DEL> Go back  <ESC> Exit{RESET}")
    else:
        print(f"{DIM}[:] Search  <ESC> Exit{RESET}")
    print(f"{DIM}{'─' * 40}{RESET}")
    git_status_line()


def execute_command(command):
    """Execute a git command."""
    if isinstance(command, list):
        # Direct execution without shell
        print(f"{DIM}$ {' '.join(command)}{RESET}\n")
        subprocess.run(command)
    else:
        # Handle % as current file placeholder
        if '%' in command:
            print(f"{YELLOW}Note: '%' placeholder not available in shell (use in editor){RESET}")
            command = command.replace(' %', '')
        print(f"{DIM}$ {command}{RESET}\n")
        subprocess.run(command, shell=True, executable='/opt/homebrew/bin/fish')


def reload_commands():
    """Reload COMMANDS from this file."""
    global COMMANDS
    with open(__file__, 'r') as f:
        source = f.read()
    # Extract and exec just the COMMANDS definition
    exec(compile(source, __file__, 'exec'), globals())
    return COMMANDS


def flatten_commands(commands, path=""):
    """Recursively flatten menu structure into searchable entries."""
    entries = []
    for key, content in commands.items():
        if key.startswith('_'):
            continue
        if isinstance(content, tuple):
            desc = content[0]
            cmd = content[1]
            display = f"{path}{desc}" if path else desc
            entries.append((display, content))
        else:
            submenu_desc = content.get('_desc', key)
            new_path = f"{path}{submenu_desc} → " if path else f"{submenu_desc} → "
            entries.extend(flatten_commands(content, new_path))
    return entries


def fzf_search_mode():
    """Launch fzf to search through all commands. Returns the command tuple or None."""
    entries = flatten_commands(COMMANDS)
    if not entries:
        return None

    fzf_input = "\n".join(entry[0] for entry in entries)

    try:
        result = subprocess.run(
            ['fzf', '--prompt=: ', '--height=40%', '--reverse'],
            input=fzf_input,
            capture_output=True,
            text=True
        )
        if result.returncode == 0 and result.stdout.strip():
            selected = result.stdout.strip()
            for display, content in entries:
                if display == selected:
                    return content
    except FileNotFoundError:
        print(f"{YELLOW}fzf not found{RESET}")
    return None


def main():
    current = COMMANDS
    history = []
    path = ''

    # Show git status on startup
    subprocess.run(['git', 'status'])
    print()

    while True:
        print_menu(current, path)
        key = getch()

        if key in ('\x1b', '\x03', '\x04'):  # ESC, Ctrl-C, Ctrl-D
            break
        elif key in ('\x7f', '\x08'):  # DEL, Backspace
            if history:
                current, path = history.pop()
            else:
                break
        elif key == ':':
            # fzf search mode
            result = fzf_search_mode()
            if result:
                cmd = result[1]
                stay_in_submenu = result[2] if len(result) > 2 else False
                execute_command(cmd)
                if not stay_in_submenu:
                    current = COMMANDS
                    history = []
                    path = ''
        elif key in current:
            action = current[key]
            if isinstance(action, tuple):
                # Execute command - tuple is (desc, cmd, stay_in_submenu, reload)
                cmd = action[1]
                stay_in_submenu = action[2] if len(action) > 2 else False
                should_reload = action[3] if len(action) > 3 else False
                execute_command(cmd)
                if should_reload:
                    current = reload_commands()
                    history = []
                    path = ''
                elif not stay_in_submenu:
                    # Go back to root
                    current = COMMANDS
                    history = []
                    path = ''
            else:
                # Enter submenu
                history.append((current, path))
                path = f"{path}{current.get('_desc', '')} → "
                current = action
        else:
            print(f"{YELLOW}Unknown key: {repr(key)}{RESET}\n")


if __name__ == '__main__':
    main()
