#!/bin/bash
# Lock Screen Dialog
#
# How to change the lock screen hotkey on macOS:
# 1. Open System Settings > Keyboard > Keyboard Shortcuts
# 2. Select "App Shortcuts" in the sidebar
# 3. Click the "+" button to add a new shortcut
# 4. Application: Select "All Applications"
# 5. Menu Title: Type exactly "Lock Screen" (case-sensitive)
# 6. Keyboard Shortcut: Press your desired key combination (e.g., Command+Option+Control+Q)
#
# This script is triggered by Command+Control+Q (mapped in karabiner.json)
# and triggers the lock screen after user types a random sequence

# CONFIGURATION: Change this to experiment with different methods
# Options: letters, words, numbers, mixed, sacred
METHOD="sacred"

# Generate sequence based on selected method
case $METHOD in
    letters)
        # 3 random lowercase letters
        sequence=$(LC_ALL=C tr -dc 'a-z' </dev/urandom | head -c 3)
        ;;
    words)
        # X random words from EFF diceware list
        num=1
        sequence=$(cut -f2 /Users/anthony/Developer/eff_large_wordlist.txt | sort -R | head -n $num | tr '\n' ' ' | sed 's/ $//')
        display_sequence="$sequence"
        sequence="${sequence// /}"  # Remove spaces for matching
        ;;
    numbers)
        # 3 random digits
        sequence=$(LC_ALL=C tr -dc '0-9' </dev/urandom | head -c 3)
        ;;
    mixed)
        # Mix of letters and numbers (e.g., a1b2c3)
        sequence=$(LC_ALL=C tr -dc 'a-z0-9' </dev/urandom | head -c 6)
        ;;
    sacred)
        # Random line from sacred lexicon (format: "Text _&:_ Description")
        # Filter out markdown headers (#) and empty lines, then pick random line
        full_line=$(grep -v '^#' /Users/anthony/Developer/unlock_wordlist.md | grep -v '^$' | grep '_&:_' | sort -R | head -n 1)
        # Extract the part before _&:_ (this is what user must type, in lowercase)
        sequence=$(echo "$full_line" | sed 's/ _&:_.*//' | tr '[:upper:]' '[:lower:]')
        # Extract the description (part after _&:_)
        description=$(echo "$full_line" | sed 's/.*_&:_ //')
        # Display on separate lines
        display_sequence="$description\n\033[43m$sequence\033[0m"
        ;;
    *)
        echo "Unknown method: $METHOD"
        exit 1
        ;;
esac

# Use display_sequence if set, otherwise use sequence
display="${display_sequence:-$sequence}"

echo -e "\033[41mREMEMBER: put wireless mic back in its case\033[0m"
echo -e "\033[41mCHECK the hot plate\033[0m"
echo -e "\033[41mCLOSE the webcam privacy flap\033[0m"
echo -e "\033[41m...\033[0m"
echo -e "$display"

input=""
seq_length=${#sequence}
error_state=false
while true; do
    IFS= read -n 1 -s -r char

    # Handle backspace (ASCII 127 or 8)
    if [[ "$char" == $'\x7f' || "$char" == $'\x08' ]]; then
        if [[ -n "$input" ]]; then
            input="${input%?}"  # Remove last character
            error_state=false
            echo -ne "\r\033[K${input}"  # Clear line and redisplay
        fi
        continue
    fi

    # If in error state, ignore all input except backspace
    if [[ "$error_state" == true ]]; then
        continue
    fi

    # Check if this character is correct
    pos=${#input}
    expected_char="${sequence:$pos:1}"

    if [[ "$char" == "$expected_char" ]]; then
        # Correct character
        input="${input}${char}"
        echo -ne "\r\033[K${input}"

        # Check if complete
        if [[ "$input" == "$sequence" ]]; then
            echo
            break
        fi
    else
        # Wrong character - show error and block
        input="${input}${char}"
        error_state=true
        echo -ne "\r\033[K\033[41m${input}\033[0m"  # Red background
    fi
done

osascript -e 'tell application "System Events" to keystroke "q" using {command down, option down, control down}'
sleep 0.5
pmset sleepnow
