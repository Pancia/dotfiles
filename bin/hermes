#!/usr/bin/env python3
import sys
import os
import tty
import termios
import time
import subprocess
import re
from pathlib import Path

# Debug logging
DEBUG_LOG_FILE = Path.home() / ".cache" / "hermes" / "debug.log"
_log_initialized = False

def debug_log(msg):
    """Log debug message with timestamp to file"""
    global _log_initialized
    try:
        DEBUG_LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        mode = 'w' if not _log_initialized else 'a'
        with open(DEBUG_LOG_FILE, mode) as f:
            f.write(f"[{time.time():.3f}] {msg}\n")
        _log_initialized = True
    except:
        pass

COMMANDS_FILE = Path.home() / ".config" / "hermes" / "commands.json"
COMMANDS_PY_FILE = Path.home() / ".config" / "hermes" / "commands.py"


def load_python_commands():
    """Load commands from Python config file"""
    if not COMMANDS_PY_FILE.exists():
        debug_log(f"Python commands file not found: {COMMANDS_PY_FILE}")
        return None
    try:
        import importlib.util
        spec = importlib.util.spec_from_file_location("commands", COMMANDS_PY_FILE)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        commands = getattr(module, 'COMMANDS', None)
        if commands is not None:
            debug_log(f"Loaded {len(commands)} commands from Python config")
        return commands
    except Exception as e:
        debug_log(f"Error loading Python commands: {e}")
        print(f"hermes: error loading Python commands: {e}", file=sys.stderr)
        return None


def print_json_error(filepath, error):
    """Print a pretty JSON parse error with context"""
    RED = '\033[31m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RESET = '\033[0m'
    CYAN = '\033[36m'

    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()
    except:
        print(f"{RED}hermes: JSON error: {error.msg}{RESET}", file=sys.stderr)
        return

    lineno = error.lineno
    colno = error.colno

    print(f"\n{RED}{BOLD}JSON Parse Error{RESET} {DIM}in commands.json{RESET}", file=sys.stderr)
    print(f"{DIM}{error.msg} at line {lineno}, column {colno}{RESET}\n", file=sys.stderr)

    # Show context: 2 lines before, error line, 2 lines after
    start = max(0, lineno - 3)
    end = min(len(lines), lineno + 2)

    for i in range(start, end):
        line_num = i + 1
        line = lines[i].rstrip()
        prefix = f"{DIM}{line_num:4} │{RESET} "

        if line_num == lineno:
            # Error line - highlight it
            print(f"{CYAN}{BOLD}{line_num:4} │{RESET} {line}", file=sys.stderr)
            # Show caret pointing to error column
            pointer = ' ' * (7 + colno - 1) + f'{RED}^── {error.msg}{RESET}'
            print(pointer, file=sys.stderr)
        else:
            print(f"{prefix}{line}", file=sys.stderr)

    print(file=sys.stderr)

def load_commands():
    """Load commands - try Python config first, fall back to JSON"""
    # Try Python config first
    commands = load_python_commands()
    if commands is not None:
        return commands

    # Fall back to JSON config
    if not COMMANDS_FILE.exists():
        debug_log(f"Commands file not found: {COMMANDS_FILE}")
        print(f"hermes: commands file not found: {COMMANDS_FILE}", file=sys.stderr)
        return {}
    try:
        import json
        with open(COMMANDS_FILE, 'r') as f:
            data = json.load(f)
        # Remove rc metadata key
        data.pop('__rc_loc', None)
        debug_log(f"Loaded {len(data)} commands from {COMMANDS_FILE}")
        return data
    except json.JSONDecodeError as e:
        debug_log(f"Error loading commands: {e}")
        print_json_error(COMMANDS_FILE, e)
        return (None, e.lineno)  # Return error line for vim jump
    except Exception as e:
        debug_log(f"Error loading commands: {e}")
        print(f"hermes: error loading commands: {e}", file=sys.stderr)
        return ({}, None)

def load_commands_with_retry():
    """Load commands, offering to open vim on JSON errors"""
    import subprocess
    import tty
    import termios
    import os

    while True:
        result = load_commands()
        if isinstance(result, tuple):
            data, error_line = result
            if data is None:
                # JSON error - ask user if they want to edit
                if not os.isatty(sys.stdin.fileno()):
                    sys.exit(1)

                print(f"Press any key to edit in vim, or q/Esc/Ctrl-C to quit: ", end='', flush=True)
                fd = sys.stdin.fileno()
                old_settings = termios.tcgetattr(fd)
                try:
                    tty.setraw(fd)
                    ch = sys.stdin.read(1)
                finally:
                    termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                print()

                # Quit on q, Esc, Ctrl-C, Ctrl-D
                if ch in ('q', 'Q', '\x1b', '\x03', '\x04', '\x7f', '\x08'):
                    sys.exit(1)
                else:
                    # Open vim at error line
                    subprocess.run(['/opt/homebrew/bin/nvim', f'+{error_line}', str(COMMANDS_FILE)])
                    continue  # Retry after editing
            return data
        return result

def getch():
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        return sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

def print_commands(commands_list, command_history):
    # ANSI color codes
    BOLD_CYAN = '\033[1;96m'    # Bold cyan for hotkeys
    BOLD_WHITE = '\033[1;37m'   # Bold white for labels
    BOLD_YELLOW = '\033[1;93m'  # Bold yellow for submenu hotkeys
    YELLOW = '\033[33m'         # Yellow for submenu labels
    DIM_GRAY = '\033[2;37m'     # Dim gray for commands
    RESET = '\033[0m'           # Reset formatting

    # Collect entries as (shortcut, formatted_string, plain_length)
    entries = []
    for shortcut, content in commands_list.items():
        if shortcut.startswith('_'):
            continue
        elif isinstance(content, list):
            (description, command) = content
            display_title = resolve_dynamic_title(description)
            formatted = f"{BOLD_CYAN}[{shortcut}]{RESET} {BOLD_WHITE}{display_title}{RESET}"
            plain_len = len(f"[{shortcut}] {display_title}")
            entries.append((shortcut, formatted, plain_len))
        elif callable(content):
            # Callable generator - show as lazy submenu
            display_title = content.__name__.replace('build_', '').replace('_menu', '').replace('_', ' ').title()
            formatted = f"{BOLD_YELLOW}[{shortcut}]{RESET} {YELLOW}→ {display_title}...{RESET}"
            plain_len = len(f"[{shortcut}] → {display_title}...")
            entries.append((shortcut, formatted, plain_len))
        else:
            description = content["_desc"]
            display_title = resolve_dynamic_title(description)
            formatted = f"{BOLD_YELLOW}[{shortcut}]{RESET} {YELLOW}→ {display_title}{RESET}"
            plain_len = len(f"[{shortcut}] → {display_title}")
            entries.append((shortcut, formatted, plain_len))

    # Add search command as a menu item
    formatted = f"{BOLD_CYAN}[:]{RESET} {BOLD_WHITE}Search all commands{RESET}"
    plain_len = len("[:] Search all commands")
    entries.append((':', formatted, plain_len))

    # Sort entries by shortcut key
    entries.sort(key=lambda x: x[0].lower())

    if not entries:
        return

    # Get terminal width
    try:
        term_width = os.get_terminal_size().columns
    except OSError:
        term_width = 80

    # Calculate column layout
    max_width = max(e[2] for e in entries) + 2  # +2 for padding
    num_cols = max(1, term_width // max_width)
    num_rows = (len(entries) + num_cols - 1) // num_cols

    # Print in columns (fill by column, read by row)
    for row in range(num_rows):
        line_parts = []
        for col in range(num_cols):
            idx = col * num_rows + row
            if idx < len(entries):
                shortcut, formatted, plain_len = entries[idx]
                padding = ' ' * (max_width - plain_len)
                line_parts.append(formatted + padding)
        print(''.join(line_parts).rstrip())

    if command_history:
        print(f"\n{DIM_GRAY}<DEL> - Go back up a level{RESET}")
    print(f"{DIM_GRAY}<ESC> <Ctrl-C> <Ctrl-D> - EXIT{RESET}")

def resolve_dynamic_title(title):
    """
    Resolve dynamic parts in a title string.
    Supports $(command) syntax for shell command substitution.
    Supports #!fish: prefix to execute entire title in fish shell.

    Examples:
        "Current time: $(date +%H:%M)" -> "Current time: 14:30"
        "$(date +%A)" -> "Saturday"
        "#!fish:hello $(echo world)" -> "hello world"
    """
    # Check for fish shebang prefix - execute entire title in fish
    if title.startswith('#!fish:'):
        fish_cmd = title[7:]  # Strip '#!fish:' prefix
        try:
            result = subprocess.run(
                ['/opt/homebrew/bin/fish', '--no-config', '-c', fish_cmd],
                stdin=subprocess.DEVNULL,
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode == 0:
                return result.stdout.strip()
            else:
                err = result.stderr.strip().split('\n')[0][:50] if result.stderr else "unknown"
                return f"[fish error: {err}]"
        except subprocess.TimeoutExpired:
            debug_log(f"Fish title command timed out: {fish_cmd}")
            return "[timeout]"
        except Exception as e:
            debug_log(f"Fish title error: {e}")
            return "[error]"

    if '$(' not in title:
        return title

    def replace_command(match):
        cmd = match.group(1)
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=1,
                executable='/bin/sh'
            )
            return result.stdout.strip() if result.returncode == 0 else f"[{cmd}]"
        except subprocess.TimeoutExpired:
            debug_log(f"Dynamic title command timed out: {cmd}")
            return f"[timeout]"
        except Exception as e:
            debug_log(f"Dynamic title error for '{cmd}': {e}")
            return f"[error]"

    # Match $(command) patterns, handling nested parentheses
    pattern = r'\$\(([^)]+)\)'
    return re.sub(pattern, replace_command, title)

def flatten_commands(commands, path=""):
    """
    Recursively flatten menu structure into searchable entries.

    Returns list of tuples: (display_string, command)
    """
    entries = []
    for key, content in commands.items():
        if key.startswith('_'):
            continue

        if isinstance(content, list):
            # Leaf command
            description = content[0]
            command = content[1]
            display_title = resolve_dynamic_title(description)
            display = f"{path}{display_title}" if path else display_title
            entries.append((display, command))
        elif callable(content):
            # Callable generator - invoke to include in search
            resolved = content()
            submenu_desc = resolved.get('_desc', key)
            display_desc = resolve_dynamic_title(submenu_desc)
            new_path = f"{path}{display_desc} → " if path else f"{display_desc} → "
            entries.extend(flatten_commands(resolved, new_path))
        else:
            # Submenu - recurse with _desc in path
            submenu_desc = content.get('_desc', key)
            display_desc = resolve_dynamic_title(submenu_desc)
            new_path = f"{path}{display_desc} → " if path else f"{display_desc} → "
            entries.extend(flatten_commands(content, new_path))

    return entries

def fzf_search_mode(commands):
    """
    Launch fzf to search through all commands recursively.
    Returns the command to execute, or None if cancelled.
    """
    entries = flatten_commands(commands)
    if not entries:
        return None

    # Format entries for fzf
    fzf_input = "\n".join(entry[0] for entry in entries)

    try:
        result = subprocess.run(
            ['/opt/homebrew/bin/fzf', '--prompt=: ', '--height=40%', '--reverse', '--ansi'],
            input=fzf_input,
            capture_output=True,
            text=True
        )

        if result.returncode == 0 and result.stdout.strip():
            selected = result.stdout.strip()
            # Find the matching entry
            for display, command in entries:
                if display == selected:
                    return command
    except FileNotFoundError:
        print("fzf not found. Please install fzf.")
    except Exception as e:
        debug_log(f"fzf search error: {e}")

    return None

def execute_command(command):
    """
    Execute a command and return (should_quit, should_reload).

    Returns:
        tuple: (should_quit, should_reload) - whether to quit and whether to reload commands
    """
    start = time.time()
    should_quit = False
    should_reload = False
    is_vpc_command = isinstance(command, str) and '.vpc' in command

    # Check if this is editing the Hermes config (should reload after)
    if isinstance(command, str) and ('hermes.json' in command or 'commands.json' in command or 'hermes_commands.py' in command or 'commands.py' in command):
        should_reload = True

    # Support both list (direct execution) and string (shell execution) syntax
    if isinstance(command, list):
        # Direct execution without shell
        print(f"Running command: {' '.join(command)}")
        debug_log(f"Starting command (direct): {' '.join(command)}")
        try:
            subprocess.run(command, shell=False, check=True, env=os.environ)
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command completed: {' '.join(command)} ({elapsed:.1f}ms)")
            if is_vpc_command:
                should_quit = True
        except subprocess.CalledProcessError as e:
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command failed: {' '.join(command)} - {e} ({elapsed:.1f}ms)")
            print(f"Command '{' '.join(command)}' failed with error: {e}")
    else:
        # Shell-based execution (existing behavior)
        print(f"Running command: {command}")
        debug_log(f"Starting command (shell): {command}")
        try:
            subprocess.run(command, shell=True, check=True, executable='/opt/homebrew/bin/fish')
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command completed: {command} ({elapsed:.1f}ms)")
            if is_vpc_command:
                should_quit = True
        except subprocess.CalledProcessError as e:
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command failed: {command} - {e} ({elapsed:.1f}ms)")
            print(f"Command '{command}' failed with error: {e}")

    return should_quit, should_reload

def main():
    import datetime
    debug_log(f"=== Controls Modal - {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ===")
    debug_log(f"Args: {sys.argv}")

    # Load commands (deferred from module level for faster startup)
    commands = load_commands_with_retry()

    current_commands = commands
    command_history = []

    # Handle command-line argument to auto-execute a command
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        debug_log(f"Auto-execute mode: {arg}")
        if arg == 'apps' and 'a' in current_commands:
            # Auto-execute app launcher
            action = current_commands['a']
            if isinstance(action, list):
                command = action[1]
                # If command is a list, extend it with the 'apps' argument
                if isinstance(command, list):
                    _, _ = execute_command(command + ['apps'])
                else:
                    # Shell command - append argument as string
                    _, _ = execute_command(f"{command} apps")
                # Don't return - continue to show main menu
        elif arg == 'windows' and 'w' in current_commands:
            # Auto-execute window switcher and exit
            action = current_commands['w']
            if isinstance(action, list):
                execute_command(action[1])
                sys.exit(0)

    while True:
        # os.system('clear')
        print_commands(current_commands, command_history)
        user_input = getch()
        print(f"Command {user_input} {user_input.encode().hex()}")

        if user_input in current_commands:
            action = current_commands[user_input]

            # Resolve callable generators on first access (lazy loading)
            if callable(action):
                debug_log(f"Resolving generator for key '{user_input}'")
                action = action()  # Call the generator
                current_commands[user_input] = action  # Cache result

            if isinstance(action, list):
                should_quit, should_reload = execute_command(action[1])
                if should_reload:
                    debug_log("Reloading commands after config edit")
                    commands = load_commands_with_retry()
                    current_commands = commands
                    command_history = []
                if should_quit:
                    debug_log("Quitting after VPC command execution")
                    break
            else:
                command_history.append(current_commands)
                current_commands = action
        elif user_input in ['\x1b', '\x03', '\x04']:
            print("Exiting program...")
            break
        elif user_input in ['\x7f', '\x08']:
            if command_history:
                current_commands = command_history.pop()
        elif user_input == ':':
            # fzf search mode
            debug_log("Entering fzf search mode")
            command = fzf_search_mode(commands)
            if command:
                should_quit, should_reload = execute_command(command)
                if should_reload:
                    debug_log("Reloading commands after config edit (fzf)")
                    commands = load_commands_with_retry()
                    current_commands = commands
                    command_history = []
                if should_quit:
                    debug_log("Quitting after fzf command execution")
                    break
        else:
            print(f"Command {user_input} {user_input.encode().hex()} not found. Please try again.")

if __name__ == '__main__':
    main()
