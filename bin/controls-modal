#!/usr/bin/env python3
import time
from pathlib import Path

# Debug logging
DEBUG_LOG_FILE = Path.home() / ".cache" / "controls-modal" / "debug.log"
_log_initialized = False

def debug_log(msg):
    """Log debug message with timestamp to file"""
    global _log_initialized
    try:
        DEBUG_LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        mode = 'w' if not _log_initialized else 'a'
        with open(DEBUG_LOG_FILE, mode) as f:
            f.write(f"[{time.time():.3f}] {msg}\n")
        _log_initialized = True
    except:
        pass

# ============================================================================
# VPC CONFIGURATION
# ============================================================================

# User-defined static VPC key mappings
# Format: {'key': 'vpc_filename_without_extension'}
VPC_STATIC_MAP = {
    # Example: 's': 'simplymeet',
    # Add your preferred VPC shortcuts here
}

VPC_DIR = Path.home() / "dotfiles" / "vpc"

def get_vpc_files():
    """Scan VPC directory and return list of .vpc files"""
    if not VPC_DIR.exists():
        debug_log(f"VPC directory not found: {VPC_DIR}")
        return []

    vpc_files = []
    for file_path in VPC_DIR.glob("*.vpc"):
        vpc_files.append(file_path)

    debug_log(f"Found {len(vpc_files)} VPC files")
    return vpc_files

def parse_vpc_metadata(vpc_path):
    """Parse VPC JSON file to extract metadata for description"""
    try:
        import json
        with open(vpc_path, 'r') as f:
            data = json.load(f)

        parts = []
        if data.get('space'):
            parts.append(f"Space {data['space']}")
        # Check for both lowercase and titlecase variants
        if data.get('iterm') or data.get('iTerm2'):
            parts.append("iTerm")
        if data.get('chrome') or data.get('Chrome'):
            parts.append("Chrome")
        if data.get('brave') or data.get('Brave Browser'):
            parts.append("Brave")
        if data.get('apps'):
            parts.append("Apps")
        if data.get('board'):
            parts.append("Board")
        if data.get('yabai'):
            parts.append("Yabai")

        if parts:
            return " • ".join(parts)
        else:
            return "VPC Workspace"
    except Exception as e:
        debug_log(f"Error parsing VPC metadata from {vpc_path}: {e}")
        return "VPC Workspace"

def build_vpc_menu():
    """Build VPC menu with smart key assignment and conflict resolution"""
    vpc_files = get_vpc_files()
    if not vpc_files:
        return {
            '_desc': 'VPC Workspaces',
            'x': ('No VPC files found', 'echo "No .vpc files found in ~/dotfiles/vpc/"')
        }

    # Create a mapping of vpc_name -> vpc_path
    vpc_map = {}
    for vpc_path in vpc_files:
        vpc_name = vpc_path.stem  # filename without extension
        vpc_map[vpc_name] = vpc_path

    # Start with static mappings
    menu = {'_desc': 'VPC Workspaces'}
    assigned_vpcs = set()

    # First pass: assign static mappings
    for key, vpc_name in VPC_STATIC_MAP.items():
        if vpc_name in vpc_map:
            vpc_path = vpc_map[vpc_name]
            menu[key] = (vpc_name, f"open '{vpc_path}'")
            assigned_vpcs.add(vpc_name)
            debug_log(f"Static assignment: {key} -> {vpc_name}")

    # Second pass: assign remaining VPCs dynamically
    unassigned_vpcs = [name for name in vpc_map.keys() if name not in assigned_vpcs]

    if unassigned_vpcs:
        menu = assign_vpc_keys(menu, unassigned_vpcs, vpc_map)

    return menu

def assign_vpc_keys(menu, vpc_names, vpc_map, depth=0):
    """
    Recursively assign keys to VPCs based on their names.
    Handle conflicts by creating nested menus.

    Args:
        menu: Current menu dict to populate
        vpc_names: List of VPC names to assign
        vpc_map: Mapping of vpc_name -> vpc_path
        depth: Current character index for key selection
    """
    if depth > 10:  # Safety limit
        debug_log(f"Warning: Max recursion depth reached for VPC assignment")
        return menu

    # Group VPCs by their nth character
    char_groups = {}
    for vpc_name in vpc_names:
        if depth < len(vpc_name):
            char = vpc_name[depth].lower()
        else:
            # If we've exhausted the name, use a fallback
            char = '0'

        if char not in char_groups:
            char_groups[char] = []
        char_groups[char].append(vpc_name)

    # Assign keys
    for char, vpcs in char_groups.items():
        if char in menu and not isinstance(menu[char], dict):
            # Key already used by a static mapping, try next character
            debug_log(f"Key '{char}' already used, creating nested menu for {vpcs}")
            # Create a nested menu for these VPCs
            vpc_list = ", ".join(sorted(vpcs))
            if len(vpc_list) > 50:
                vpc_list = vpc_list[:47] + "..."
            nested_menu = {'_desc': vpc_list}
            menu[char + char] = assign_vpc_keys(nested_menu, vpcs, vpc_map, depth + 1)
        elif len(vpcs) == 1:
            # Single VPC, assign directly (no metadata, just name)
            vpc_name = vpcs[0]
            vpc_path = vpc_map[vpc_name]
            menu[char] = (vpc_name, f"open '{vpc_path}'")
            debug_log(f"Dynamic assignment: {char} -> {vpc_name}")
        else:
            # Multiple VPCs with same character, create nested menu
            debug_log(f"Conflict on '{char}': {vpcs} - creating nested menu")
            # Create description showing contained VPC names
            vpc_list = ", ".join(sorted(vpcs))
            if len(vpc_list) > 50:
                vpc_list = vpc_list[:47] + "..."
            if char not in menu or not isinstance(menu[char], dict):
                menu[char] = {'_desc': vpc_list}
            menu[char] = assign_vpc_keys(menu[char], vpcs, vpc_map, depth + 1)

    return menu

commands = {
        'c': ('CAT', 'echo cat'),
        'a': ('App Launcher', ['/Users/anthony/dotfiles/bin/app-launcher']),
        'y': {
            '_desc': 'ytdl',
            'i': ("ytdl interactive", 'ytdl'),
            'y': ("ytdl clipboard", 'ytdl clipboard'),
            },
        'm': {
            '_desc': 'music',
            'c': ("Play or Pause", 'cmus-remote --pause'),
            'e': ("Edit Track", 'cmedit'),
            'y': ("Redownload from Youtube", 'cmytdl'),
            'a': ("Open Track in Audacity", 'cmaudacity'),
            's': ("Select Track by Playlist", 'cmselect'),
            't': ("Select Track by Tags", 'cmselect --filter-by-tags'),
            'n': ("Next Track", 'cmus-remote --next'),
            'p': ("Prev Track", 'cmus-remote --prev'),
            'l': ("Seek 10 Forwards", 'cmus-remote --seek +10'),
            'h': ("Seek 10 Backwards", 'cmus-remote --seek -10'),
            '.': ("Seek 30 Forwards", 'cmus-remote --seek +30'),
            ',': ("Seek 30 Backwards", 'cmus-remote --seek -30'),
            'j': ("Volume Down", 'cmus-remote --volume -5'),
            'k': ("Volume Up", 'cmus-remote --volume +5')
            }
        }

import sys, tty, termios
def getch():
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        return sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

def print_commands(commands_list, command_history):
    # ANSI color codes
    BOLD_CYAN = '\033[1;96m'    # Bold cyan for hotkeys
    BOLD_WHITE = '\033[1;37m'   # Bold white for labels
    BOLD_YELLOW = '\033[1;93m'  # Bold yellow for submenu hotkeys
    YELLOW = '\033[33m'         # Yellow for submenu labels
    DIM_GRAY = '\033[2;37m'     # Dim gray for commands
    RESET = '\033[0m'           # Reset formatting

    for shortcut, content in commands_list.items():
        if shortcut[0] == '_':
            pass
        elif isinstance(content, tuple):
            (description, command) = content
            # Regular command - cyan hotkey, white label
            print(f"{BOLD_CYAN}[{shortcut}]{RESET} {BOLD_WHITE}{description}{RESET}")
        else:
            # Submenu - yellow hotkey with arrow before label
            description = content["_desc"]
            print(f"{BOLD_YELLOW}[{shortcut}]{RESET} {YELLOW}→ {description}{RESET}")

    if command_history:
        print(f"\n{DIM_GRAY}<DEL> - Go back up a level{RESET}")
    print(f"{DIM_GRAY}<ESC> <Ctrl-C> <Ctrl-D> - EXIT{RESET}")

import subprocess
def execute_command(command):
    """
    Execute a command and return whether to quit the modal.

    Returns:
        bool: True if should quit after execution, False otherwise
    """
    start = time.time()
    should_quit = False

    # Check if this is a VPC command (should quit after execution)
    if isinstance(command, str) and '.vpc' in command:
        should_quit = True

    # Support both list (direct execution) and string (shell execution) syntax
    if isinstance(command, list):
        # Direct execution without shell
        print(f"Running command: {' '.join(command)}")
        debug_log(f"Starting command (direct): {' '.join(command)}")
        try:
            subprocess.run(command, shell=False, check=True, env=os.environ)
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command completed: {' '.join(command)} ({elapsed:.1f}ms)")
        except subprocess.CalledProcessError as e:
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command failed: {' '.join(command)} - {e} ({elapsed:.1f}ms)")
            print(f"Command '{' '.join(command)}' failed with error: {e}")
    else:
        # Shell-based execution (existing behavior)
        print(f"Running command: {command}")
        debug_log(f"Starting command (shell): {command}")
        try:
            subprocess.run(command, shell=True, check=True, executable='/opt/homebrew/bin/fish')
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command completed: {command} ({elapsed:.1f}ms)")
        except subprocess.CalledProcessError as e:
            elapsed = (time.time() - start) * 1000
            debug_log(f"Command failed: {command} - {e} ({elapsed:.1f}ms)")
            print(f"Command '{command}' failed with error: {e}")

    return should_quit

import os
def main():
    import datetime
    debug_log(f"=== Controls Modal - {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ===")
    debug_log(f"Args: {sys.argv}")

    # Build VPC menu dynamically and inject into commands
    global commands
    commands['v'] = build_vpc_menu()
    debug_log(f"VPC menu built with {len(commands['v']) - 1} entries")  # -1 for _desc

    current_commands = commands
    command_history = []

    # Handle command-line argument to auto-execute a command
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        debug_log(f"Auto-execute mode: {arg}")
        if arg == 'apps' and 'a' in current_commands:
            # Auto-execute app launcher
            action = current_commands['a']
            if isinstance(action, tuple):
                command = action[1]
                # If command is a list, extend it with the 'apps' argument
                if isinstance(command, list):
                    execute_command(command + ['apps'])
                else:
                    # Shell command - append argument as string
                    execute_command(f"{command} apps")
                # Don't return - continue to show main menu

    while True:
        # os.system('clear')
        print_commands(current_commands, command_history)
        user_input = getch()
        print(f"Command {user_input} {user_input.encode().hex()}")
        if user_input in current_commands:
            action = current_commands[user_input]
            if isinstance(action, tuple):
                should_quit = execute_command(action[1])
                if should_quit:
                    debug_log("Quitting after VPC command execution")
                    break
            else:
                command_history.append(current_commands)
                current_commands = action
        elif user_input in ['\x1b', '\x03', '\x04']:
            print("Exiting program...")
            break
        elif user_input in ['\x7f', '\x08']:
            if command_history:
                current_commands = command_history.pop()
        else:
            print(f"Command {user_input} {user_input.encode().hex()} not found. Please try again.")

if __name__ == '__main__':
    main()
